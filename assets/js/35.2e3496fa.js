(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{519:function(a,t,s){"use strict";s.r(t);var r=s(2),n=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"c-语言树和二叉树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#c-语言树和二叉树"}},[a._v("#")]),a._v(" C 语言树和二叉树")]),a._v(" "),t("h2",{attrs:{id:"树的概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#树的概念"}},[a._v("#")]),a._v(" 树的概念")]),a._v(" "),t("p",[a._v("树是一种非线性的数据结构，它是由n(n>=0)个有限结点组成一个具有层次关系的集合。把它叫做树是因 为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("有一个特殊的结点，称为根结点，根节点没有前驱结点")])]),a._v(" "),t("li",[t("p",[a._v("除根节点外，其余结点被分成M(M>0)个互不相交的集合T1、T2、......、Tm，其中每一个集合Ti(1<= i <= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继 因此，树是递归定义的。")])])]),a._v(" "),t("p",[a._v("注意:树形结构中，子树之间不能有交集，否则就不是树形结构")]),a._v(" "),t("p",[a._v("![image-20230915191733137](/Users/mac/Library/Application Support/typora-user-images/image-20230915191733137.png)")]),a._v(" "),t("h2",{attrs:{id:"树的相关概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#树的相关概念"}},[a._v("#")]),a._v(" 树的相关概念")]),a._v(" "),t("p",[t("strong",[a._v("节点的度")]),a._v(":一个节点含有的子树的个数称为该节点的度; 如上图:A的为6")]),a._v(" "),t("p",[t("strong",[a._v("叶节点或终端节点")]),a._v(":度为0的节点称为叶节点; 如上图:B、C、H、I...等节点为叶节点")]),a._v(" "),t("p",[t("strong",[a._v("非终端节点或分支节点")]),a._v(":度不为0的节点; 如上图:D、E、F、G...等节点为分支节点")]),a._v(" "),t("p",[t("strong",[a._v("双亲节点或父节点")]),a._v(":若一个节点含有子节点，则这个节点称为其子节点的父节点; 如上图:A是B的父节点")]),a._v(" "),t("p",[t("strong",[a._v("孩子节点或子节点")]),a._v(":一个节点含有的子树的根节点称为该节点的子节点; 如上图:B是A的孩子节点")]),a._v(" "),t("p",[t("strong",[a._v("兄弟节点")]),a._v(":具有相同父节点的节点互称为兄弟节点; 如上图:B、C是兄弟节点")]),a._v(" "),t("p",[t("strong",[a._v("树的度")]),a._v(":一棵树中，最大的节点的度称为树的度; 如上图:树的度为6")]),a._v(" "),t("p",[t("strong",[a._v("节点的层次")]),a._v(":从根开始定义起，根为第1层，根的子节点为第2层，以此类推;")]),a._v(" "),t("p",[t("strong",[a._v("树的高度或深度")]),a._v(":树中节点的最大层次; 如上图:树的高度为4")]),a._v(" "),t("p",[t("strong",[a._v("堂兄弟节点")]),a._v(":双亲在同一层的节点互为堂兄弟;如上图:H、I互为兄弟节点")]),a._v(" "),t("p",[t("strong",[a._v("节点的祖先")]),a._v(":从根到该节点所经分支上的所有节点;如上图:A是所有节点的祖先")]),a._v(" "),t("p",[t("strong",[a._v("子孙")]),a._v(":以某节点为根的子树中任一节点都称为该节点的子孙。如上图:所有节点都是A的子孙")]),a._v(" "),t("p",[t("strong",[a._v("森林")]),a._v(":由m(m>0)棵互不相交的树的集合称为森林;")]),a._v(" "),t("h2",{attrs:{id:"树的表示"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#树的表示"}},[a._v("#")]),a._v(" 树的表示")]),a._v(" "),t("p",[a._v("树结构相对线性表就比较复杂了，要存储表示起来就比较麻烦了，既然保存值域，也要保存结点和结点之间的关系，实际中树有很多种表示方式如:双亲表示法，孩子表示法、孩子双亲表示法以及孩子兄弟表示法\n等。我们这里就简单的了解其中最常用的"),t("strong",[a._v("孩子兄弟表示法")]),a._v("。")]),a._v(" "),t("div",{staticClass:"language-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("typedef")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" DataType"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("struct")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Node")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("struct")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Node")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" _firstChild1"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 第一个孩子结点")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("struct")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Node")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" _pNextBrother"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 指向其下一个兄弟结点 // 结点中的数据域")]),a._v("\n    DataType _data"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("p",[a._v("![image-20230915192223548](/Users/mac/Library/Application Support/typora-user-images/image-20230915192223548.png)")]),a._v(" "),t("p",[a._v("树在实际中的运用(表示文件系统的目录树结构")]),a._v(" "),t("h2",{attrs:{id:"二叉树的概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的概念"}},[a._v("#")]),a._v(" 二叉树的概念")]),a._v(" "),t("p",[a._v("一棵二叉树是结点的一个有限集合，该集合:")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("或者为空")])]),a._v(" "),t("li",[t("p",[a._v("由一个根节点加上两棵别称为左子树和右子树的二叉树组成")])])]),a._v(" "),t("p",[a._v("![image-20230915192640625](/Users/mac/Library/Application Support/typora-user-images/image-20230915192640625.png)")]),a._v(" "),t("p",[a._v("从上图可以看出:")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("二叉树不存在度大于2的结点")])]),a._v(" "),t("li",[t("p",[a._v("二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树")])])]),a._v(" "),t("p",[a._v("注意:对于任意的二叉树都是由以下几种情况复合而成的:")]),a._v(" "),t("p",[a._v("![image-20230915192731912](/Users/mac/Library/Application Support/typora-user-images/image-20230915192731912.png)")]),a._v(" "),t("h2",{attrs:{id:"特殊的二叉树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特殊的二叉树"}},[a._v("#")]),a._v(" 特殊的二叉树")]),a._v(" "),t("ol",[t("li",[a._v("满二叉树:一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是 说，如果一个二叉树的层数为K，且结点总数是 ，则它就是满二叉树。")]),a._v(" "),t("li",[a._v("完全二叉树:完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K 的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对 应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。")])]),a._v(" "),t("p",[a._v("![image-20230915193140399](/Users/mac/Library/Application Support/typora-user-images/image-20230915193140399.png)")]),a._v(" "),t("h2",{attrs:{id:"二叉树的性质"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的性质"}},[a._v("#")]),a._v(" 二叉树的性质")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("若规定根节点的层数为1，则一棵非空二叉树的第i层上最多有 个结点.")])]),a._v(" "),t("li",[t("p",[a._v("若规定根节点的层数为1，则深度为h的二叉树的最大结点数是 .")])]),a._v(" "),t("li",[t("p",[a._v("对任何一棵二叉树, 如果度为0其叶结点个数为 , 度为2的分支结点个数为 ,则有 = +1")])]),a._v(" "),t("li",[t("p",[a._v("若规定根节点的层数为1，具有n个结点的满二叉树的深度，h= . (ps: 为底，n+1为对数)是log以2为底，n+1为对数)")])]),a._v(" "),t("li",[t("p",[a._v("对于具有n个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有节点从0开始编号，则对于序号为i的结点有:")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("若i>0，i位置节点的双亲序号:(i-1)/2;i=0，i为根节点编号，无双亲节点")])]),a._v(" "),t("li",[t("p",[a._v("若2i+1 < n，左孩子序号:2i+1，2i+1>=n否则无左孩子")])]),a._v(" "),t("li",[t("p",[a._v("若2i+2 < n，右孩子序号:2i+2，2i+2>=n否则无右孩子")])])])])]),a._v(" "),t("h2",{attrs:{id:"二叉树的存储结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的存储结构"}},[a._v("#")]),a._v(" 二叉树的存储结构")]),a._v(" "),t("p",[a._v("二叉树一般可以使用两种结构存储，一种顺序结构，一种链式结构。")]),a._v(" "),t("h6",{attrs:{id:"顺序存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#顺序存储"}},[a._v("#")]),a._v(" 顺序存储")]),a._v(" "),t("p",[a._v("顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空间的浪费。而现实中使用中只有堆才会使用数组来存储，关于堆我们后面的章节会专门讲解。二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树。")]),a._v(" "),t("p",[a._v("![image-20230915193748233](/Users/mac/Library/Application Support/typora-user-images/image-20230915193748233.png)")]),a._v(" "),t("h6",{attrs:{id:"链式存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链式存储"}},[a._v("#")]),a._v(" 链式存储")]),a._v(" "),t("p",[a._v("二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是 链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所 在的链结点的存储地址 。链式结构又分为二叉链和三叉链，当前我们学习中一般都是二叉链，后面课程 学到高阶数据结构如红黑树等会用到三叉链。")]),a._v(" "),t("p",[a._v("二叉链表")]),a._v(" "),t("p",[a._v("![image-20230915194515555](/Users/mac/Library/Application Support/typora-user-images/image-20230915194515555.png)")]),a._v(" "),t("p",[a._v("![image-20230915194302305](/Users/mac/Library/Application Support/typora-user-images/image-20230915194302305.png)")]),a._v(" "),t("p",[a._v("三叉链表")]),a._v(" "),t("p",[a._v("![image-20230915194539529](/Users/mac/Library/Application Support/typora-user-images/image-20230915194539529.png)")]),a._v(" "),t("p",[a._v("![image-20230915194418070](/Users/mac/Library/Application Support/typora-user-images/image-20230915194418070.png)")]),a._v(" "),t("h2",{attrs:{id:"二叉树的顺序结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的顺序结构"}},[a._v("#")]),a._v(" 二叉树的顺序结构")]),a._v(" "),t("p",[a._v("普通的二叉树是不适合用数组来存储的，因为可能会存在大量的空间浪费。而完全二叉树更适合使用顺序结 构存储。现实中我们通常把堆(一种二叉树)使用顺序结构的数组来存储，需要注意的是这里的堆和操作系统 虚拟进程地址空间中的堆是两回事，一个是数据结构，一个是操作系统中管理内存的一块区域分段。")]),a._v(" "),t("p",[a._v("![image-20230915200801973](/Users/mac/Library/Application Support/typora-user-images/image-20230915200801973.png)")]),a._v(" "),t("h2",{attrs:{id:"堆的概念及结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆的概念及结构"}},[a._v("#")]),a._v(" 堆的概念及结构")]),a._v(" "),t("p",[a._v("如果有一个关键码的集合K = { ， ， ，...， }，把它的所有元素按完全二叉树的顺序存储方式存储 在一个一维数组中，并满足: <= 且 <= ( >= 且 >= ) i = 0，1， 2...，则称为小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。")]),a._v(" "),t("p",[a._v("堆的性质:")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("堆中某个节点的值总是不大于或不小于其父节点的值;")])]),a._v(" "),t("li",[t("p",[a._v("堆总是一棵完全二叉树。")])])]),a._v(" "),t("p",[a._v("![image-20230915195729300](/Users/mac/Library/Application Support/typora-user-images/image-20230915195729300.png)")]),a._v(" "),t("h2",{attrs:{id:"堆向下调整算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆向下调整算法"}},[a._v("#")]),a._v(" 堆向下调整算法")]),a._v(" "),t("p",[a._v("现在我们给出一个数组，逻辑上看做一颗完全二叉树。我们通过从根节点开始的向下调整算法可以把它调整\n成一个小堆。向下调整算法有一个前提:左右子树必须是一个堆，才能调整。")]),a._v(" "),t("div",{staticClass:"language-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" array"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("27")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("15")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("19")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("18")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("28")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("34")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("65")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("49")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("25")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("37")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("p",[a._v("![image-20230923121009051](/Users/mac/Library/Application Support/typora-user-images/image-20230923121009051.png)")]),a._v(" "),t("h2",{attrs:{id:"堆的创建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆的创建"}},[a._v("#")]),a._v(" 堆的创建")]),a._v(" "),t("p",[a._v("下面我们给出一个数组，这个数组逻辑上可以看做一颗完全二叉树，但是还不是一个堆，现在我们通过算\n法，把它构建成一个堆。根节点左右子树不是堆，我们怎么调整呢?这里我们从倒数的第一个非叶子节点的\n子树开始调整，一直调整到根节点的树，就可以调整成堆。")]),a._v(" "),t("div",{staticClass:"language-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("8")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("7")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("6")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("p",[a._v("![image-20230923121243047](/Users/mac/Library/Application Support/typora-user-images/image-20230923121243047.png)")]),a._v(" "),t("h2",{attrs:{id:"堆的插入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆的插入"}},[a._v("#")]),a._v(" 堆的插入")]),a._v(" "),t("p",[a._v("先插入一个10到数组的尾上，再进行向上调整算法，直到满足堆。")]),a._v(" "),t("p",[a._v("![image-20230922123516575](/Users/mac/Library/Application Support/typora-user-images/image-20230922123516575.png)")]),a._v(" "),t("h2",{attrs:{id:"建堆的时间复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#建堆的时间复杂度"}},[a._v("#")]),a._v(" 建堆的时间复杂度")]),a._v(" "),t("p",[a._v("因为堆是完全二叉树，而满二叉树也是完全二叉树，此处为了简化使用满二叉树来证明(时间复杂度本来看的就是近似值，多几个节点不影响最终结果):")]),a._v(" "),t("p",[a._v("![image-20230923121346982](/Users/mac/Library/Application Support/typora-user-images/image-20230923121346982.png)")]),a._v(" "),t("p",[a._v("因此:建堆的时间复杂度为O(N)。")]),a._v(" "),t("h2",{attrs:{id:"堆的删除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆的删除"}},[a._v("#")]),a._v(" 堆的删除")]),a._v(" "),t("p",[a._v("删除堆是删除堆顶的数据，将堆顶的数据根最后一个数据一换，然后删除数组最后一个数据，再进行向下调")]),a._v(" "),t("p",[a._v("整算法。")]),a._v(" "),t("p",[a._v("![image-20230923120835574](/Users/mac/Library/Application Support/typora-user-images/image-20230923120835574.png)")]),a._v(" "),t("h2",{attrs:{id:"链式二叉树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链式二叉树"}},[a._v("#")]),a._v(" 链式二叉树")]),a._v(" "),t("div",{staticClass:"language-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("typedef")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" BTDataType"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("typedef")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("struct")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("BinaryTreeNode")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    BTDataType _data"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("struct")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("BinaryTreeNode")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" _left"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("struct")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("BinaryTreeNode")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" _right"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("BTNode"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nBTNode"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("CreatBinaryTree")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  \t"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 创建节点")]),a._v("\n    BTNode"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" node1 "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("BuyNode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    BTNode"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" node2 "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("BuyNode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    BTNode"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" node3 "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("BuyNode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    BTNode"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" node4 "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("BuyNode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    BTNode"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" node5 "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("BuyNode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    BTNode"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" node6 "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("BuyNode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("6")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  \n  \t"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 链接成树")]),a._v("\n    node1"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v("_left "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" node2"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    node1"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v("_right "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" node4"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    node2"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v("_left "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" node3"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    node4"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v("_left "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" node5"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    node4"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v("_right "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" node6"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" node1"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("![image-20231017160001069](/Users/mac/Library/Application Support/typora-user-images/image-20231017160001069.png)")]),a._v(" "),t("h2",{attrs:{id:"二叉树的遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的遍历"}},[a._v("#")]),a._v(" 二叉树的遍历")]),a._v(" "),t("ol",[t("li",[a._v("前序遍历(Preorder Traversal 亦称先序遍历)——访问根结点的操作发生在遍历其左右子树之前。 （根->左子树->右子树）")]),a._v(" "),t("li",[a._v("中序遍历(Inorder Traversal)——访问根结点的操作发生在遍历其左右子树之中(间)。 （左子树->根->右子树）")]),a._v(" "),t("li",[a._v("后序遍历(Postorder Traversal)——访问根结点的操作发生在遍历其左右子树之后。（左子树->右子树->根）")])])])}),[],!1,null,null,null);t.default=n.exports}}]);
---
title: C语言树和二叉树
date: 2023/09/14
tags:
  - C语言
  - 数据结构
categories:
  - backend
---

# C 语言树和二叉树

## 树的概念

树是一种非线性的数据结构，它是由n(n>=0)个有限结点组成一个具有层次关系的集合。把它叫做树是因 为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

- 有一个特殊的结点，称为根结点，根节点没有前驱结点 

- 除根节点外，其余结点被分成M(M>0)个互不相交的集合T1、T2、......、Tm，其中每一个集合Ti(1<= i <= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继 因此，树是递归定义的。

注意:树形结构中，子树之间不能有交集，否则就不是树形结构

![image-20230915191733137](/Users/mac/Library/Application Support/typora-user-images/image-20230915191733137.png)

## 树的相关概念

**节点的度**:一个节点含有的子树的个数称为该节点的度; 如上图:A的为6 

**叶节点或终端节点**:度为0的节点称为叶节点; 如上图:B、C、H、I...等节点为叶节点 

**非终端节点或分支节点**:度不为0的节点; 如上图:D、E、F、G...等节点为分支节点 

**双亲节点或父节点**:若一个节点含有子节点，则这个节点称为其子节点的父节点; 如上图:A是B的父节点 

**孩子节点或子节点**:一个节点含有的子树的根节点称为该节点的子节点; 如上图:B是A的孩子节点 

**兄弟节点**:具有相同父节点的节点互称为兄弟节点; 如上图:B、C是兄弟节点 

**树的度**:一棵树中，最大的节点的度称为树的度; 如上图:树的度为6 

**节点的层次**:从根开始定义起，根为第1层，根的子节点为第2层，以此类推; 

**树的高度或深度**:树中节点的最大层次; 如上图:树的高度为4 

**堂兄弟节点**:双亲在同一层的节点互为堂兄弟;如上图:H、I互为兄弟节点 

**节点的祖先**:从根到该节点所经分支上的所有节点;如上图:A是所有节点的祖先 

**子孙**:以某节点为根的子树中任一节点都称为该节点的子孙。如上图:所有节点都是A的子孙 

**森林**:由m(m>0)棵互不相交的树的集合称为森林;

## 树的表示

 树结构相对线性表就比较复杂了，要存储表示起来就比较麻烦了，既然保存值域，也要保存结点和结点之间的关系，实际中树有很多种表示方式如:双亲表示法，孩子表示法、孩子双亲表示法以及孩子兄弟表示法
 等。我们这里就简单的了解其中最常用的**孩子兄弟表示法**。

```c
typedef int DataType;
struct Node
{
    struct Node* _firstChild1;// 第一个孩子结点
    struct Node* _pNextBrother;// 指向其下一个兄弟结点 // 结点中的数据域
    DataType _data;
};
```

![image-20230915192223548](/Users/mac/Library/Application Support/typora-user-images/image-20230915192223548.png)

树在实际中的运用(表示文件系统的目录树结构



## 二叉树的概念

一棵二叉树是结点的一个有限集合，该集合: 

1. 或者为空

2. 由一个根节点加上两棵别称为左子树和右子树的二叉树组成

![image-20230915192640625](/Users/mac/Library/Application Support/typora-user-images/image-20230915192640625.png)

从上图可以看出:

1. 二叉树不存在度大于2的结点

2. 二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树

注意:对于任意的二叉树都是由以下几种情况复合而成的:

![image-20230915192731912](/Users/mac/Library/Application Support/typora-user-images/image-20230915192731912.png)



## 特殊的二叉树

1. 满二叉树:一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是 说，如果一个二叉树的层数为K，且结点总数是 ，则它就是满二叉树。
2. 完全二叉树:完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K 的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对 应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。

![image-20230915193140399](/Users/mac/Library/Application Support/typora-user-images/image-20230915193140399.png)

## 二叉树的性质

1. 若规定根节点的层数为1，则一棵非空二叉树的第i层上最多有 个结点.
2. 若规定根节点的层数为1，则深度为h的二叉树的最大结点数是 .
3. 对任何一棵二叉树, 如果度为0其叶结点个数为 , 度为2的分支结点个数为 ,则有 = +1

4. 若规定根节点的层数为1，具有n个结点的满二叉树的深度，h= . (ps: 为底，n+1为对数)是log以2为底，n+1为对数)

5. 对于具有n个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有节点从0开始编号，则对于序号为i的结点有:

   - 若i>0，i位置节点的双亲序号:(i-1)/2;i=0，i为根节点编号，无双亲节点

   - 若2i+1 < n，左孩子序号:2i+1，2i+1>=n否则无左孩子 
   - 若2i+2 < n，右孩子序号:2i+2，2i+2>=n否则无右孩子



## 二叉树的存储结构

二叉树一般可以使用两种结构存储，一种顺序结构，一种链式结构。

###### 顺序存储

顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空间的浪费。而现实中使用中只有堆才会使用数组来存储，关于堆我们后面的章节会专门讲解。二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树。

![image-20230915193748233](/Users/mac/Library/Application Support/typora-user-images/image-20230915193748233.png)

###### 链式存储

二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是 链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所 在的链结点的存储地址 。链式结构又分为二叉链和三叉链，当前我们学习中一般都是二叉链，后面课程 学到高阶数据结构如红黑树等会用到三叉链。

二叉链表

![image-20230915194515555](/Users/mac/Library/Application Support/typora-user-images/image-20230915194515555.png)

![image-20230915194302305](/Users/mac/Library/Application Support/typora-user-images/image-20230915194302305.png)

三叉链表

![image-20230915194539529](/Users/mac/Library/Application Support/typora-user-images/image-20230915194539529.png)

![image-20230915194418070](/Users/mac/Library/Application Support/typora-user-images/image-20230915194418070.png)



## 二叉树的顺序结构

普通的二叉树是不适合用数组来存储的，因为可能会存在大量的空间浪费。而完全二叉树更适合使用顺序结 构存储。现实中我们通常把堆(一种二叉树)使用顺序结构的数组来存储，需要注意的是这里的堆和操作系统 虚拟进程地址空间中的堆是两回事，一个是数据结构，一个是操作系统中管理内存的一块区域分段。

![image-20230915200801973](/Users/mac/Library/Application Support/typora-user-images/image-20230915200801973.png)

## 堆的概念及结构

如果有一个关键码的集合K = { ， ， ，...， }，把它的所有元素按完全二叉树的顺序存储方式存储 在一个一维数组中，并满足: <= 且 <= ( >= 且 >= ) i = 0，1， 2...，则称为小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。

堆的性质:

- 堆中某个节点的值总是不大于或不小于其父节点的值;

- 堆总是一棵完全二叉树。

![image-20230915195729300](/Users/mac/Library/Application Support/typora-user-images/image-20230915195729300.png)

## 堆向下调整算法

现在我们给出一个数组，逻辑上看做一颗完全二叉树。我们通过从根节点开始的向下调整算法可以把它调整
 成一个小堆。向下调整算法有一个前提:左右子树必须是一个堆，才能调整。

```c
int array[] = {27,15,19,18,28,34,65,49,25,37};
```

![image-20230923121009051](/Users/mac/Library/Application Support/typora-user-images/image-20230923121009051.png)

## 堆的创建

下面我们给出一个数组，这个数组逻辑上可以看做一颗完全二叉树，但是还不是一个堆，现在我们通过算
 法，把它构建成一个堆。根节点左右子树不是堆，我们怎么调整呢?这里我们从倒数的第一个非叶子节点的
 子树开始调整，一直调整到根节点的树，就可以调整成堆。

```c
int a[] = {1,5,3,8,7,6};
```

![image-20230923121243047](/Users/mac/Library/Application Support/typora-user-images/image-20230923121243047.png)

## 堆的插入

先插入一个10到数组的尾上，再进行向上调整算法，直到满足堆。

![image-20230922123516575](/Users/mac/Library/Application Support/typora-user-images/image-20230922123516575.png)

## 建堆的时间复杂度

因为堆是完全二叉树，而满二叉树也是完全二叉树，此处为了简化使用满二叉树来证明(时间复杂度本来看的就是近似值，多几个节点不影响最终结果):

![image-20230923121346982](/Users/mac/Library/Application Support/typora-user-images/image-20230923121346982.png)

因此:建堆的时间复杂度为O(N)。

## 堆的删除

删除堆是删除堆顶的数据，将堆顶的数据根最后一个数据一换，然后删除数组最后一个数据，再进行向下调

整算法。

![image-20230923120835574](/Users/mac/Library/Application Support/typora-user-images/image-20230923120835574.png)

## 链式二叉树

```c
typedef int BTDataType;
typedef struct BinaryTreeNode
{
    BTDataType _data;
    struct BinaryTreeNode* _left;
    struct BinaryTreeNode* _right;
}BTNode;
BTNode* CreatBinaryTree()
{
  	// 创建节点
    BTNode* node1 = BuyNode(1);
    BTNode* node2 = BuyNode(2);
    BTNode* node3 = BuyNode(3);
    BTNode* node4 = BuyNode(4);
    BTNode* node5 = BuyNode(5);
    BTNode* node6 = BuyNode(6);
  
  	// 链接成树
    node1->_left = node2;
    node1->_right = node4;
    node2->_left = node3;
    node4->_left = node5;
    node4->_right = node6;
    return node1;
}
```



![image-20231017160001069](/Users/mac/Library/Application Support/typora-user-images/image-20231017160001069.png)



## 二叉树的遍历

1. 前序遍历(Preorder Traversal 亦称先序遍历)——访问根结点的操作发生在遍历其左右子树之前。 （根->左子树->右子树）
2. 中序遍历(Inorder Traversal)——访问根结点的操作发生在遍历其左右子树之中(间)。 （左子树->根->右子树）
3. 后序遍历(Postorder Traversal)——访问根结点的操作发生在遍历其左右子树之后。（左子树->右子树->根）

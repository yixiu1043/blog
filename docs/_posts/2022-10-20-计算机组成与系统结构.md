---
title: 计算机组成与系统结构
date: 2022-10-20
tags:
  - 网课
category: 前端
banner: /blog/img/banner/62.jpeg
---

#  计算机组成与系统结构

组成：硬件 + 软件

fortram

pascal

c++

java



## 计算机硬件的基本组成

1.组成

- 运算器+控制器，简称CPU

- 主存储器
- 输入+输出设备



主机：主存储器+CPU

存储器：主存+辅存

I/O设备：输入+输出设备



2.存储器

- 存储体
- MAR，存储地址寄存器（Memory Address Register） 
- MDR，存储数据寄存器（Memory Data Register）

存储单元：每个存储单元存放一串二进制代码

存储字（word）：存储单元中二进制代码的组合

存储字长：存储单元中二进制代码的位数 8｜16 ｜ 32 ｜64

存储元：存储二进制的电子元件，每个存储元可存 1bit

MAR=4位 -> 总共有2**4个存储单元

MDR=16位 -> 每个存储单元可存放16bit，1个字（word）=16bit

1个字节（Byte）= 8bit

1B = 1个字节，1b=1个bit



3.运算器

ACC 累加器 Accumulator

MQ 乘商寄存器 Multiple-Quotient Register

X 通用操作数寄存器 

ALU 算数逻辑单元，核心部件 Arithmetic And Logic Unit



4.控制器

CU 控制单元 Control Unit

IR 指令寄存器 Instruction Register

PC 程序计数器 Program Center

 PC -> IR -> CU

取指令  PC 

分析指令 IR

执行指令 CU



## 计算机系统的层次结构

虚拟机语言 M4（高级语言机器）

虚拟机器 M3 （汇编语言机器）

虚拟机器 M2（操作系统机器）

传统机器 M1（用机器语言的机器）

微程序机器 M0 （微指令系统）



`三个级别的语言`:

- 高级语言
- 汇编语言
- 机器语言

`两种语言类型`：

- 编译型语言（一次性全部翻译为汇编语言）
- 解释型语言（翻译一句，执行一句）



## 计算机性能指标

### 存储器的性能指标

总容量 = 存储单元个数x存储字长

例子：

MAR为32位，MDR为8位

总容量 = 2 \** 32 \* 8bit= 4GB

IByte = 8bit



### CPU的性能指标

CPU主频：CPU内数字脉冲信号振荡的频率

CPU主频（时钟频率）= 1 / CPU时钟周期



CPI（Clock cycle Per Instruction）：执行一条指令所需的时钟周期数



CPU执行时间（整个程序的耗时）= CPU时钟周期数 / 主频 = （指令条数 * CPI）/ 主频



IPS（Instruction Per Second）：每秒执行多少条指令

IPS = 主频 / 平均CPI



FLOPS（Floating-point Operations Per Second）：每秒执行多少次浮点运算



### 系统整理的性能指标

数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）

吞吐量：指系统在单位时间内处理请求的数量。

响应时间：用户向计算机发送请求，到系统对该请求做出响应并获得所需结果的等待时间



### 动态测试

基准程序

使用跑分软件进行动态测试



## 进位计数制

### 进制转换

真值：符合人类习惯的数字

机器数：数字实际存到机器里的形式，正负号需要被“数字化”



#### r进制：

K<sub>n</sub>K<sub>n-1</sub>...K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>...K<sub>-m</sub>

= K<sub>n</sub>✖️r<sup>n</sup>➕K<sub>n-1</sub>✖️r<sup>n-1</sup>➕...➕K<sub>2</sub>✖️r<sup>2</sup>➕K<sub>1</sub>✖️r<sup>1</sup>➕K<sub>0</sub>✖️r<sup>0</sup>➕K<sub>-1</sub>✖️r<sup>-1</sup>➕K<sub>-2</sub>✖️r<sup>-2</sup>➕...➕K<sub>-m</sub>✖️r<sup>-m</sup>

基数：每个数码位所用到的不同符号的个数，R进制的基数为R，二进制为2，十进制为10。

位权（r<sup>n</sup>）：由符号处的位置所确定的权值权重。



#### 任意进制转十进制

例子：

将二进制1001 0010.110转化为十进制。

1001 0010.110 

= 1 * 2<sup>7</sup> +  0 * 2<sup>6</sup> +  0 * 2<sup>5</sup> +  1 * 2<sup>4</sup> +  0 * 2<sup>3</sup> +  0 * 2<sup>2</sup> +  1 * 2<sup>1</sup> +  0 * 2<sup>0</sup> +  1 * 2<sup>-1</sup>  +  1 * 2<sup>-2</sup> +  0 * 2<sup>-3</sup> 

= 128 + 16 + 2 + 0.5 + 0.25

= 146.75

| 2<sup>7</sup> | 2<sup>6</sup> | 2<sup>5</sup> | 2<sup>4</sup> | 2<sup>3</sup> | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> | 2<sup>-1</sup> | 2<sup>-2</sup> | 2<sup>-3</sup> |
| ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | -------------- | -------------- | -------------- |
| 128           | 64            | 32            | 16            | 8             | 4             | 2             | 1             | 0.5            | 0.25           | 0.125          |
| 1             | 0             | 0             | 1             | 0             | 0             | 1             | 0             | 1              | 1              | 0              |



#### 二进制转八进制、十六进制

如：1111 0000 10.0110 01

##### 二进制转八进制

3位一组，不够补0，每组转换成对应的八进制符号

| 001  | 111  | 000  | 010  | .    | 011  | 010  |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 7    | 0    | 2    | .    | 3    | 2    |

结果：1702.32

##### 二进制转十六进制

4位一组，不够补0，每组转换成对应的十六进制符号

| 0011 | 1100 | 0010 | .    | 0110 | 1000 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 3    | C    | 2    | .    | 6    | 8    |

结果：3C2.68



### 各种进制的常见书写方式

二进制：(1010)<sub>2</sub> 		1010B

八进制：(1652)<sub>8</sub> 

十进制：(1652)<sub>10</sub> 		1652D

十六进制：(1652)<sub>16</sub> 		1652H 	0x1652



### 十进制转任意进制

如：75.3		

整数部分=75

``除基取余法``
$$
K_n*r^n+K_{n-1}*r^{n-1}+...+K_2*r^2+K_1*r^1+K_0*r^0 = 75 {, 根据r进制可得}
$$

$$
\frac {K_n*r^n+K_{n-1}*r^{n-1}+...+K_2*r^2+K_1*r^1+K_0*r^0} {r} 
= K_n*r^{n-1}+K_{n-1}*r^{n-2}+...+K_2*r^1+K_1*r^0...K_0 {，前面部分是商，K_0是余数}
$$

$$
\frac {K_n*r^{n-1}+K_{n-1}*r^{n-2}+...+K_2*r^1+K_1*r^0} {r} 
= K_n*r^{n-2}+K_{n-1}*r^{n-3}+...+K_2*r^0...K_1 {，前面部分是商，K_1是余数}
$$

把商记做x，则： r * x  + K<sub>0</sub>

(r * x  + K<sub>0</sub>) / r，余 K<sub>0</sub> 。



小数部分=0.3

``乘基取整法``
$$
(K_{-1}*r^{-1}+K_{-2}*r^{-2}+...+K_{-m}*r^{-m}) * r
= K_{-1}*r^0+K_{-2}*r^{-1}+...+K_{-m}*r^{-(m+1)} {，K_{-1}*r^0为整数}
$$

$$
(K_{-2}*r^{-1}+...+K_{-m}*r^{-(m+1)}) * r
= K_{-2}*r^0+...+K_{-m}*r^{-(m+2)} {，K_{-2}*r^0为整数}
$$



#### 十进制转二进制

基数r = 2

整数部分=75

75 ➗ 2 = 37 ... 1,  (K<sub>0</sub> )

37 ➗ 2 = 18 ... 1,  (K<sub>1</sub> )

18 ➗ 2 = 9 ... 0,  (K<sub>2</sub> )

9 ➗ 2 = 4 ... 1,  (K<sub>3</sub>)

4 ➗ 2 = 2 ... 0,  (K<sub>4</sub>)

2 ➗ 2 = 1 ... 0,  (K<sub>5</sub>)

1 ➗ 2 = 0 ... 1,  (K<sub>6</sub>)

最后得：75D = 1001011B



小数部分=0.3

0.3✖️2 = 0.6 = 0 + 0.6 , (K<sub>-1</sub> )

0.6✖️2 = 1.2 = 1 + 0.2 , (K<sub>-2</sub> )

0.2✖️2 = 0.4 = 0 + 0.4 , (K<sub>-3</sub> )

0.4✖️2 = 0.8 = 0 + 0.8 , (K<sub>-4</sub> )

0.8✖️2 = 1.6 = 1 + 0.6 , (K<sub>-5</sub> )

...

无法精确表示

最后得：0.3D = 0.01001B



75.3D = 1001011.01001B



##### 拼凑法

| 2<sup>12</sup> | 2<sup>11</sup> | 2<sup>10</sup> | 2<sup>9</sup> | 2<sup>8</sup> | 2<sup>7</sup> | 2<sup>6</sup> | 2<sup>5</sup> | 2<sup>4</sup> | 2<sup>3</sup> | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> | 2<sup>-1</sup> | 2<sup>-2</sup> | 2<sup>-3</sup> |
| -------------- | -------------- | -------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | -------------- | -------------- | -------------- |
| 4096           | 2048           | 1024           | 512           | 256           | 128           | 64            | 32            | 16            | 8             | 4             | 2             | 1             | 0.5            | 0.25           | 0.125          |
| 260.75         |                |                |               | 1             | 0             | 0             | 0             | 0             | 0             | 1             | 0             | 0.            | 1              | 1              |                |
| 533.125        |                |                | 1             | 0             | 0             | 0             | 0             | 1             | 0             | 1             | 0             | 1.            | 0              | 0              | 1              |

例子：

将十进制260.75，533.125转为二进制

260.75 = 256 + 4 + 0.5 + 0.25 = 1000 0010 0.11

533.125 = 512 + 16 + 4 + 1 + 0.125 = 1000 0101 01.001



#### 十进制转八进制

r = 8

与转二进制的方法相同



### BCD码

定义：Binary-Coded Decimal，用二进制编码的十进制

作用：方便人类进行转换

原理：用4个二进制位表示1个十进制字符。



#### 8421码

有权码

| 2<sup>3</sup> | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> | 权重              |
| ------------- | ------------- | ------------- | ------------- | ----------------- |
| 8             | 4             | 2             | 1             | 真值              |
| x             | x             | x             | x             | 4个比特位         |
| 0             | 1             | 0             | 1             | 5 = 4 + 1 = 0101B |
| 1             | 0             | 0             | 1             | 9 = 8 + 1 = 1001B |

8421码映射表

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 |

例子：985

9 = 1001

8 = 1000

5 = 0101

985D = 1001 1000 0101B

 

##### 计算机如何使用8421码进行加法

计算机用8421码得出13的二进制的步骤

8421码中1010-1111没有定义

13不在8421码范围内，计算机要做加6处理

十进制：     5      +        8      =    13

8421码：

1. 0101   +     1000   =    1101（不在8421表中）
2. 1101   +     0110（8421表中的6）   =    10011 
3. =   0001 0011（高位补0）



#### 余3码

无权码

在8421码的基础上加3得来

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 |



#### 2421码

| 2<sup>1</sup> | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> | 权重                  |
| ------------- | ------------- | ------------- | ------------- | --------------------- |
| 2             | 4             | 2             | 1             | 真值                  |
| x             | x             | x             | x             | 4个比特位             |
| 0             | 0             | 1             | 1             | 3 = 2 + 1 = 0011B     |
| 1             | 0             | 1             | 1             | 5 = 2 + 2 + 1 = 1101B |

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0000 | 0001 | 0010 | 0011 | 0100 | 1011 | 1100 | 1101 | 1110 | 1111 |

2421码规定：

0～4编码以0开头，5以后的数字以1开头。



## 字符与字符串

ASCII码

可印刷字符：32-126

其余为控制、通信字符：0-31，127

汉字编码



## 奇偶校验码

码距



## 海明校验码

纠错能力

检错能力



## 循环冗余校验码 CRC码

约定除数，检验余数



## 定点数的表示

定点数：小数点的位置固定，例如：996.007    --常规计数

浮点数：小数点的位置不固定，例如；9.96007✖️10<sup>2</sup>  -- 科学计数法



### 无符号数

定义：整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。

表示范围：

前提条件，用多少个比特位表示。

8位二进制数：2<sup>8</sup>种不同的状态 0000 0000 ～ 1111 1111（0 ～ 255）

n位的无符号数表示范围为：0～2<sup>n-1</sup>

*无符号数只能表示整数，不能表示小数。*



### 有符号数

有符号位

#### 定点整数

| 符号位 | 数   | 值   | 部   | 分   | 小数点（隐含） |
| ------ | ---- | ---- | ---- | ---- | -------------- |
| x      | x    | x    | x    | x    | .              |

#### 定点小数

| 符号位 | 小数点（隐含） | 数   | 值   | 部   | 分   |
| ------ | -------------- | ---- | ---- | ---- | ---- |
| x      | .              | x    | x    | x    | x    |

用定点的方式表示19.75，则需要分别保存整数部分和小数部分。

用来表示数值部分的二进制位也称作“尾数”。

用[x]<sub>原</sub>、[x]<sub>反</sub>、[x]<sub>补</sub>、[x]<sub>移</sub>的书写方式来表示x的原码、反码、补码、移码。



#### 原码

用尾数表示真值的绝对值，符号位“0/1”对应“正/负”。

*若机器字长为 n+1 位，则尾数占 n 位。*

定点整数的表示范围：-(2<sup>n</sup> - 1) ~ 2<sup>n</sup> - 1

定点小数的表示范围：-(1 - 2<sup>-n</sup> ) ~ 1 - 2<sup>-n</sup>

 真值0有 +0 和 -0 两种形式。

如机器字长为8位。

| 符号 | 2<sup>6</sup> | 2<sup>5</sup> | 2<sup>4</sup> | 2<sup>3</sup> | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> |                               |
| ---- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ----------------------------- |
| 0    | 0             | 0             | 1             | 0             | 0             | 1             | 1             | +19D = 16 + 2 + 1 = 0001 0011 |
| 1    | 0             | 0             | 1             | 0             | 0             | 1             | 1             | -19D = 16 + 2 + 1 = 1001 0011 |

| 符号 | 2<sup>-1</sup> | 2<sup>-2</sup> | 2<sup>-3</sup> | 2<sup>-4</sup> | 2<sup>-5</sup> | 2<sup>-6</sup> | 2<sup>-7</sup> |                                 |
| ---- | -------------- | -------------- | -------------- | -------------- | -------------- | -------------- | -------------- | ------------------------------- |
| 0    | 1              | 1              | 0              | 0              | 0              | 0              | 0              | +0.75D = 0.5 + 0.25 = 0110 0000 |
| 1    | 1              | 1              | 0              | 0              | 0              | 0              | 0              | -0.75D = 0.5 + 0.25 = 1110 0000 |

#### 反码

若符号位为0，则反码与原码相同

若符号位为1，则数值位全部取反

*反码是原码转换为补码的一个中间态，实际中并没有什么用*

定点整数的表示范围：-(2<sup>n</sup> - 1) ~ 2<sup>n</sup> - 1

定点小数的表示范围：-(1 - 2<sup>-n</sup> ) ~ 1 - 2<sup>-n</sup>

 真值0有 +0 和 -0 两种形式。



#### 补码

若符号位为0，则补码与原码相同

若符号位为1，则补码=反码末位+1（要考虑进位）

定点整数[x]<sub>补</sub> = 1,0000000 表示 x = -2<sup>7</sup> = -128

定点整数的表示范围：-2<sup>n</sup> ~ 2<sup>n</sup> - 1（比原码多表示一个-2<sup>n</sup>）

定点小数[x]<sub>补</sub> = 1,0000000 表示 x = -1

定点小数的表示范围：-1  ~ 1 - 2<sup>-n</sup>

 真值0只有一种形式。



#### 移码

在补码的基础上将符号位取反。

移码只能用于表示整数。

移码表示的整数很方便对比大小。

 真值0只有一种形式。



#### 拓展

###### 由[x]<sub>补</sub>快速求[-x]<sub>补</sub>或由[-x]<sub>补</sub>快速求[x]<sub>补</sub>的方法。

符号位、数值位全部取反，末位+1。

###### 由[-x]<sub>补</sub>快速求[-x]<sub>原</sub>的方法。

1. 符号位保持不变、数值位全部取反，末位+1。
2. 最右边的1及其右边同原码，最右边的1的左边同反码



## 各种码的作用

#### 原码/反码/补码

用硬件电路实现加法是简单的，实现减法是比较困难的，如果硬件既要实现加法功能又要实现减法功能就会导致硬件的设计成本增加，同时复杂度也增加。

用加法运算实现减法运算。

###### 时钟的例子：

将时钟从10点调到7点，逆时针调3个，顺时针调9个。

10 -3 = 7

10 + 9 = 19，19 mod 12 = 7

-3 = 9(mod 12)

###### 模运算的性质

-3 = (-1)*12 + 9

9 = 0*12 + 9

21 = 1*12 + 9

33 = 2*12 + 9

-15 = (-2)*12 + 9

...

（mod12）把所有整数分为12类（余数为0～11）

mod12余数相同的数，都是同一类，都是等价的

即10+(-3)、10+9、10+21...在（mod12）的条件下效果相同



｜-3｜+｜9｜ = 12，我们称两个数互为补数。

模 - a的绝对值 = a的补数（是正数）



###### 有符号数的加法

用8bit可表示的范围：0000 0000 ～ 2<sup>8</sup> -1，天然模2<sup>8</sup>

14 + -14 = 0; 

0000 1110 + 1000 1110 = 1001 1100 = -28

期望得到0，实际得到-28

​	0000 1110

\+ 1000 1110

\-------------------

​	 0000 1110

\+ 10000 0000 (2<sup>8</sup>) - 0000 1110

\-------------------

​	0000 1110

\+ 1111 0010

\-------------------

10000 0000（高位1自动被舍弃，得到期望的结果0）



补码的作用：使用补码可将减法操作转变为等价的加法，ALU中无需集成减法器。执行加法操作时，符号位一起参与运算。

#### 移码

真值的递增和移码的绝对值的递增是保持一致的，所以用移码表示的整数很方便对比大小。





## 定点数的移位运算

#### 算数移位

985.211

小数点后移1位相当✖️10<sup>1</sup>

小数点前移1位相当➗10<sup>1</sup>

**定义：**

通过改变各个数码位和小数点的相对位置，从而改变各个数码位的位权。可用移位运算实现乘法、除法。

|          | 符号位 | 2<sup>6</sup> | 2<sup>5</sup> | 2<sup>4</sup> | 2<sup>3</sup> | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> | 小数点 |      | 数值 | 右移 | 0～127            |
| -------- | ------ | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------ | ---- | ---- | ---- | ----------------- |
| 原码     | 1      | 0             | 0             | 1             | 0             | 1             | 0             | 0             | .      |      | -20D |      |                   |
| 算数右移 | 1      | 0             | 0             | 0             | 1             | 0             | 1             | 0             | .      | 0    | -10D | 1位  | -20➗2<sup>1</sup> |
|          | 1      | 0             | 0             | 0             | 0             | 1             | 0             | 1             | .      | 0    | -5D  | 2位  | -20➗2<sup>2</sup> |
|          | 1      | 0             | 0             | 0             | 0             | 0             | 1             | 0             | .      | 1    | -2D  | 3位  | -20➗2<sup>3</sup> |
| 算数左移 | 1      | 0             | 1             | 0             | 1             | 0             | 0             | 0             | .      |      | -40D | 1位  | -20✖️2<sup>1</sup> |
|          | 1      | 1             | 0             | 1             | 0             | 0             | 0             | 0             | .      |      | -80D | 2位  | -20✖️2<sup>2</sup> |
|          | 1      | 0             | 1             | 0             | 0             | 0             | 0             | 0             | .      |      | -32D | 3位  | -20✖️2<sup>3</sup> |

-20 / 8 = 2.5

原码的算数移位：符号位保持不变，仅对数值进行移位。

右移：高位补0，低位舍弃。若舍弃的位等于0，则相当于➗2，若舍弃的位不等于0，则会丢失精度。

左移：低位补0，高位舍弃。若舍弃的位等于0，则相当于✖️2，若舍弃的位不等于0，则会出现严重误差。



#### 反码的算数移位

**正数**

右移：高位补0，低位舍弃。

左移：低位补0，高位舍弃。

**负数**

右移：高位补1，低位舍弃。

左移：低位补1，高位舍弃。



#### 补码的算数移位

**正数**

右移：高位补0，低位舍弃。

左移：低位补0，高位舍弃。

**负数**

右移：高位补1，低位舍弃。同反码。

左移：低位补0，高位舍弃。同补码。



##### 算数移位应用举例

计算机如何处理-20 x 7

7D = 111B = 2<sup>0</sup>+2<sup>1</sup>+2<sup>2</sup>

=> -20 x (2<sup>0</sup>+2<sup>1</sup>+2<sup>2</sup>)

=> -20 -> 左移0位  + -20 -> 左移1位 + -20 -> 左移2位

*计算机硬件实现乘法是基于算数移位和加法进行的。*



#### 逻辑移位

右移：高位补0，低位舍弃。

左移：低位补0，高位舍弃。

*可以把逻辑移位看作是对“无符号数”的算数移位*。

##### 逻辑移位应用举例

RGB颜色的存储

RGB(102, 139, 139)

R = 102D -> 01100110 

G = 139D -> 10001011 

B = 139D -> 10001011

用3B存储无符号数102，并逻辑左移16位。 

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   | 19   | 20   | 21   | 22   | 23   | 24   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 1    | 0    | 0    | 1    | 1    | 0    |
| 0    | 1    | 1    | 0    | 0    | 1    | 1    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

用3B存储无符号数139，并逻辑左移8位。 

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   | 19   | 20   | 21   | 22   | 23   | 24   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    | 0    | 1    | 0    | 1    | 1    |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    | 0    | 1    | 0    | 1    | 1    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

用3B存储无符号数139。

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   | 19   | 20   | 21   | 22   | 23   | 24   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    | 0    | 1    | 0    | 1    | 1    |

相加得到3B的RGB值。

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   | 19   | 20   | 21   | 22   | 23   | 24   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | 1    | 0    | 0    | 1    | 1    | 0    | 1    | 0    | 0    | 0    | 1    | 0    | 1    | 1    | 1    | 0    | 0    | 0    | 1    | 0    | 1    | 1    |



#### 循环移位

右移：高位补移出的低位。

左移：低位补移出的高位。



## 定点数的加减运算和移出判断

### 原码的加减运算

#### 加法运算：

正 + 正 =》绝对值做加法，结果为正

负 + 负 =》绝对值做加法，结果为负

正 + 负 =》绝对值大的减绝对值小的，符号同绝对值大的数

正 + 负 =》绝对值大的减绝对值小的，符号同绝对值大的数



#### 减法运算：

“减数”符号取反，转变为加法。

正 - 负 =》正 + 正

负 - 正 =》负 + 负

正 - 正 =》正 + 负

负 + 正 =》负 - 负



### 补码的加减运算

因为原码的加减运算实现太复杂了，所以计算机使用补码来进行加减运算。

对于补码来说，无论加法还是减法，最后都会转变为加法，由加法器实现运算，符号位也参与运算。

#### 溢出判断

下溢  ｜  负数区   ｜  	0	｜	正数区	｜	上溢	

​				-128							  +127

###### 上溢

只有“正数”+“正数”才会上溢 --- 正 + 正 = 负

###### 下溢

只有“负数”+“负数”才会下溢 --- 负 + 负 = 正



#### 计算机判断溢出的方法

##### 方法一

采用一位符号位。

设A的符号为A<sub>s</sub>，设B的符号为B<sub>s</sub>，运算结果为S<sub>s</sub>，则溢出逻辑表达式为：
$$
V = A_sB_s\overline{S_s} + \overline{A_s}\overline{B_s}S_s
$$
若V=0，表示无溢出，

若V=1，表示有溢出。

A<sub>s</sub>为1且B<sub>s</sub>为1且S<sub>s</sub>为0  =>  正 + 正 = 负。

A<sub>s</sub>为0且B<sub>s</sub>为0且S<sub>s</sub>为1  =>  负 + 负 = 正。



###### 逻辑表达式

与：如ABC，表示A与B与C

仅当A、B、C均为1时，ABC为1，A、B、C中有一个或多个为0，则ABC为0

或：如A+B+C，表示A或B或C

仅当A、B、C均为0时，A+B+C为0，A、B、C中有一个或多个为1，则A+B+C为1

非：如$\overline{\text{A}}$，表示A非

若A为1，则$\overline{A}$为0

若A为0，则$\overline{A}$为1



##### 方法二

采用一位符号位，根据数据位进位情况判断溢出，符号位的进位C<sub>s</sub>，最高数值位的进位C<sub>1</sub>

|      | 符号位的进位C<sub>s</sub> | 最高数值位的进位C<sub>1</sub> |
| ---- | ------------------------- | ----------------------------- |
| 上溢 | 0                         | 1                             |
| 下溢 | 1                         | 0                             |

即C<sub>s</sub>与C<sub>1</sub>不同时有溢出，计算机使用异或运算判断溢出。
$$
V = C_s \oplus C_1
$$


若V=0，表示无溢出，V=1，表示有溢出。



##### 方法三

采用双符号

正数符号位为00，负数符号位为11

正+正，当符号位出现01时，则为上溢，

负+负，当符号位出现10时，则为下溢。

记两个符号位为S<sub>s1</sub>，S<sub>s2</sub>
$$
V = S_{s1} \oplus S_{s2}
$$
若V=0，表示无溢出，V=1，表示有溢出。

*双符号位补码又称：模4补码，*

*单符号位补码又称：模2补码。*

*双符号位补码实际存储时只存储1个符号位，运算时会复制一个符号位*



#### 符号拓展

当发生溢出时，可以将短数据转换成长数据（int -> long）。多出来的位怎么填补？

Eg：8位 -> 16位

###### 正整数（原、反、补码表示都一样）

0,1011010		->		0,00000000 1011010

###### 负整数

原码：1,1011010		->		1,00000000 1011010

反码：1,1011010		->		1,11111111 0100101

补码：1,1011010		->		1,11111111 0100110



###### 正小数（原、反、补码表示都一样）

0.1011010		->		0.1011010 00000000

###### 负小数

原码：1.1011010		&rarr;		1.1011010 00000000

反码：1.1011010		&rarr;		1.0100101 11111111

补码：1.1011010		&rarr;		1.0100110 00000000



## 原码的乘法运算

### 十进制的乘法

​	0.985

x  0.211	

\-------------

​	  985

​    985

1970

\-------------

0.207835



0.211 = 2x10<sup>-1</sup> + 1x10<sup>-2</sup> + 1x10<sup>-3</sup>

0.985 = 985x10<sup>-3</sup>

0.985 x 0.211 = (985 x 1 x 10<sup>-6</sup>) +  (985 x 1 x 10<sup>-5</sup>) +  (985 x 2 x 10<sup>-4</sup>)



​	0.985

x  0.211	

\-------------

0.000985

0.00985

0.1970

\-------------

0.207835



### 二进制的乘法

与十进制同理

​	0.1101

x  0.1011	

\-------------

​	   1101

​     1101

  0000

1101

\-------------

0.10001111



乘数：0.1011 = 1x2<sup>-1</sup> + 0x2<sup>-2</sup> + 1x2<sup>-3</sup> + 1x2<sup>-4</sup>

被乘数：0.1101 = 1101x2<sup>-4</sup>

0.1101x 0.1011 = (1101 x 1 x 2<sup>-8</sup>) +  (1101 x 1 x 2<sup>-7</sup>) +  (1101 x 0 x 2<sup>-6</sup>) +  (1101 x 1 x 2<sup>-5</sup>)



​	0.1101

x  0.1011	

\-------------

0.00001101

0.0001101

0.000000

0.01101

\-------------

0.10001111



### 计算机如何实现

实现方法：先加法再移位，重复n次

符号位单独处理：异或运算
$$
V = X_s \oplus Y_s
$$
数值位取绝对值进行乘法计算

*每次移位是“原码逻辑右移”*



如：设机器字长为 n + 1 = 5位（含一位符号位），[x]<sub>原</sub> = 1.1101，[y]<sub>原</sub> = 0.1011，采用原码一位乘法求x*y。

​		乘积高位					乘数、乘积低位

​			ACC								MQ

<font color="red">0	1	0	0	0</font>	&rarr;		<font color="red">1	1	1	1</font>	0	1	0	1	1

​			&uarr;&darr;

​		  ALU

​			&uarr;

0	1	1	0	1

​			X

​		被乘数

​		



## 补码的乘法运算

补码一位乘法：

进行n轮加法、移位，最后再多来一次加法。

每次加法可能+0、+[x]补、+[-x]补

每次移位是“补码的算数右移”

乘数的符号位参与运算



根据当前MQ中的最低位、辅助位来确定加什么：

- 辅助位 - MQ中最低位 = 1时，(ACC)+[x]补
- 辅助位 - MQ中最低位 = 0时，(ACC)+0
- 辅助位 - MQ中最低位 = -1时，(ACC)+[-x]补



【辅助位】：MQ扩充一位用来表示辅助位，辅助位初始为0，每次右移会使MQ的最低位顶替原本的辅助位，（事实上MQ共n+2位）

 

## 原码的除法运算

x / y = a...b(余数b) &rarr; x = ay + b



设机器字长为 n + 1 = 5位（含一位符号位，n=4），[x]<sub>原</sub> = 0.1011，[y]<sub>原</sub> = 0.1101，求x/y。

​						 0.1101

​			  \--------------------

01101	01011

​			   00000

​			  \--------------------

​				 10110

​				 01101

​			  \--------------------

​					10010

​					01101		

​			  \--------------------

​					   01010

​					   00000

​			  \--------------------

​					     10100

​						 01101	

​			  \--------------------

​							0111



 0.1011 = 0.1101 x 0.1101 + 0.00000111

 

乘数：0.1101 = 1x2<sup>-1</sup> + 1x2<sup>-2</sup> + 0x2<sup>-3</sup> + 1x2<sup>-4</sup>

被乘数：0.1101 = 1101x2<sup>-4</sup>

0.1101x 0.1101 = (1101 x 1 x 2<sup>-8</sup>) +  (1101 x 0 x 2<sup>-7</sup>) +  (1101 x 1 x 2<sup>-6</sup>) +  (1101 x 1 x 2<sup>-5</sup>) + 0.00000111



​						   0.1101

​			  \--------------------

0.1101	0.1011

​			   0.0000

​			  \--------------------

​				0.10110

​				0.01101

​			  \--------------------

​				0.010010

​				0.001101		

​			  \--------------------

​				0.0001010

​				0.0000000

​			  \--------------------

​				0.00010100

​				0.00001101	

​			  \--------------------

​				0.00000111



### 计算机如何实现

#### 恢复余数法

实现方法：上商0或1，得到余数，余数末尾补0

符号位单独处理：异或运算
$$
V = X_s \oplus Y_s
$$
数值位取绝对值进行除法计算

*每次移位是“原码逻辑左移”*

*计算机很傻，会先默认商1，如果商错了再改商0，并恢复余数。*



如：设机器字长为 n + 1 = 5位（含一位符号位，n=4），[x]<sub>原</sub> = 0.1011，[y]<sub>原</sub> = 0.1101，采用恢复余数法求x/y。

​		被除数、余数					 商

​			ACC								MQ

0	0	1	1	1	&rarr;		<font color="red">0	1	1	0	1</font>	

​			&uarr;&darr;

​		  ALU

​			&uarr;

0	1	1	0	1

​			X

​		除数

余数 = 0.0111 x 2<sup>n</sup>



#### 加减交替法（不恢复余数法）

符号位单独处理：异或运算

数值位取绝对值进行除法计算

若余数为负，则可直接商0，让余数左移1位再加上除数的绝对值，得到下一个新余数。

若余数为正，则商1，让余数左移1位再减去除数的绝对值，得到下一个新余数。



## 补码的除法运算

#### 加减交替法

补码除法：

- 符号位参与运算
- 被除数/余数、除数采用双符号位



规则：

1. 被除数和除数同号，则被除数减去除数，异号则被除数加上除数。
2. 余数和除数同号，商1，余数左移一位减去除数，余数和除数异号，商0，余数左移一位加上除数，重复n次。
3. 末位恒置为1。



## C语言强制类型转换

定点整数：

- int：4个字节，32bit
- short： 2个字节，16bit

C语言中的定点整数是用“补码”的形式存储的。



**无符号与有符号互转：**

不改变数据内容，改变解释方式

**长整数变短整数：**

高位截断，保留低位。

**短整数变长整数：**

符号扩展



## 数据的存储和排列

大小端模式



## 浮点数的表示

### 定点数

科学计数法：

302657264526

+11+3.026

阶码+尾数

**阶码：**

阶码正负表示小数点左/右移

阶符+数值，反映数值大小

**尾数：**

数符表示整个数值正负

数符+数值，反映精度



### 浮点数

阶码： 常用补码或移码表示的定点整数

尾数：常用原码或补码表示的定点小数

浮点数的真值：N = r<sup>E</sup> x M

r：阶码的底，通常为2

E：阶码E反映浮点数的表示范围及小数点的实际位置

M：尾数M的数值部分的位数反映浮点数的精度

尾数给出一个小数，阶码指明了小数点要向前/向后移动几位

例：阶码、尾数均用补码表示，求a、b真值的二进制表示。

a = 0,01;1.1001

阶码0,01对应真值+1；

尾数1.1001对应的真值-0.0111 = -(2<sup>-2</sup>+2<sup>-3</sup>+2<sup>-4</sup>)

a的真值 = 2<sup>1</sup> x (-0.0111) = -0.111

b=0,10;0.01001

阶码0,10对应真值+2；

尾数0.01001对应的真值+0.01001 = +(2<sup>-2</sup>+2<sup>-5</sup>)

b的真值 = 2<sup>2</sup> x (+0.01001) = +1.001



#### 尾数规格化

如果尾数的最高位是无效值，会丧失精度

尾数去掉无效的最高位，例如：

2<sup>2</sup> x (+0.01001) => 2<sup>1</sup> x (+0.1001) 

规则：

尾数算数左移1位，阶码减1。直到尾数最高位是有效值（左归）



#### 浮点数尾数的规格化

规格化浮点数：规定尾数的最高位数值位必须是一个有效值。

左归：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移一位，阶码减1。

右归：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数算数右移一位，阶码加1。

例：a = 010; 00.1100, b = 010; 00.1000，求 a + b

a = 2<sup>2</sup> x 00.1100, b = 2<sup>2</sup> x 00.1000

a + b = 2<sup>2</sup> x (00.1100 +  00.1000)

​		  =  2<sup>2</sup> x 01.0100 

​		 =  2<sup>3</sup> x 00.1010



*采用“双符号位”，当溢出发生时，可以挽救。更高的符号位是正确的符号位*



### IEEE745标准

#### 移码

定义：移码 = 真值 + 偏置值

此处8位移码的偏置值=128D=1000 0000B，即2<sup>n-1</sup>

-127的移码：

真值-127 = -1111 111B

移码=-1111 111 + 1000 0000 = 0000 0001

#### IEEE745标准

规定：偏置值 = 127D = 0111 1111B，即2<sup>n-1</sup> -1

表示范围：-128～127，实际会取-126～127

特殊值：0000 0000（-127） 和 1111 11111（-128），这两个状态有特殊用途。

构成

| 数符部分      | 阶码部分（移码表示） | 尾数部分（原码表示，隐藏表示最高位1，表示成1.M） |
| ------------- | -------------------- | ------------------------------------------------ |
| m<sub>s</sub> | E                    | M                                                |



| 类型                   | 数符 | 阶码 | 尾数数值 | 总位数 | 偏置值（H） | 偏置值（D） |
| ---------------------- | ---- | ---- | -------- | ------ | ----------- | ----------- |
| 短浮点数float，单精度  | 1    | 8    | 23       | 32     | 7FH         | 127         |
| 长浮点数double，双精度 | 1    | 11   | 52       | 64     | 3FFH        | 1023        |
| 临时浮点数long double  | 1    | 15   | 64       | 80     | 3FFFH       | 16383       |

规格化的短浮点数的真值为：(-1)<sup>s</sup> x 1.M x 2<sup>E-127</sup>

规格化的长浮点数的真值为：(-1)<sup>s</sup> x 1.M x 2<sup>E-1023</sup>



例子：

将十进制数-0.75转换为IEEE754的单精度浮点数格式表示。

尾数规格化：(-0.75)<sub>10</sub> = (-0.11)<sub>2</sub> = (-1.1)<sub>2</sub> x 2<sup>-1</sup>

数符 = 1

尾数部分 = .10000000...（隐含最高位1）

阶码真值 = -1

单精度浮点数偏移量 = 127D

移码 = 阶码真值 + 偏移量 = -1 + 111 1111 = 0111 1110（凑足8位）

*也可以这么算，移码 = 阶码真值 + 偏移量 = -1 + 127 = 126 = 0111 1110（凑足8位）*

最后得：1 0111 1110 1000 0000 0000 0000 0000 000



###### IEEE 754单精度浮点型能表示的最小绝对值、最大绝对值是多少？

最小绝对值：尾数全为0，阶码真值最小-126，对应移码机器数0000 0001，此时整体的真值为 (1.0)<sub>2</sub> x 2<sup>-126</sup>

最大绝对值：尾数全为1，阶码真值最大127，对应移码机器数1111 1110，此时整体的真值为 (1.1111....11)<sub>2</sub> x 2<sup>127</sup>

| 格式   | 规格化最小绝对值                                        | 规格化最大绝对值                                             |
| ------ | ------------------------------------------------------- | ------------------------------------------------------------ |
| 单精度 | E=1，M=0： 1.0 x 2<sup>1-127</sup> = 2<sup>-126</sup>   | E=254，M=.11...1：1.11...1 x 2<sup>254-127</sup> = 2<sup>127</sup> x (2 - 2 <sup>-23</sup>) |
| 双精度 | E=1，M=0： 1.0 x 2<sup>1-1023</sup> = 2<sup>-1022</sup> | E=2046，M=.11...1：1.11...1 x 2<sup>2046-1023</sup> = 2<sup>1023</sup> x (2 - 2 <sup>-52</sup>) |



总结：

由浮点数确定真值（阶码不是全0、也不是全1）

1. 根据“某浮点数”确定数符、阶码、尾数分布
2. 确定尾数1.M（注意补充最高的隐含位1）
3. 确定阶码的真值 = 移码 - 偏置值（可将移码看作无符号数，用无符号数的值减去偏置值）
4. (-1)<sup>s</sup> x 1.M x 2<sup>E-偏置值</sup>



# 浮点数的运算

#### 浮点数加减运算步骤

1. 对阶
2. 尾数加减
3. 规格化
4. 舍入
5. 判溢出

如：9.85211 x 10<sup>12</sup> + 9.96007 x 10<sup>10</sup>

=>  9.85211 x 10<sup>12</sup> + 0.096007 x 10<sup>12</sup>

=> 9.9517107 x 10<sup>12</sup>

=> 如果尾数加减后出现类似 0.0099517107 x 10<sup>12</sup>，需要“左规”，如果尾数加减出现类似 99.517107  x 10<sup>12</sup>时，需要“右规”。

=> 若规定只能保留6位有效尾数，则 9.9517107 x 10<sup>12</sup>  &rarr;  9.951710 x 10<sup>12</sup>，多余的砍掉或者四舍五入。

=> 若规定阶码不能超过两位，则运算后阶码超出范围，则溢出，如：9.85211 x 10<sup>99</sup> + 9.96007 x 10<sup>99</sup> = 19.81218 x 10<sup>99</sup>，规格化并用四舍五入保留六位小数，得：1.981218 x 10<sup>100</sup>，阶码100超过两位，发生溢出（注：尾数发生溢出未必导致整体溢出，也许可以通过第二步、第三步来拯救）。

​	

#### 舍入规则

0舍1入法：类似十进制数运算中的“四舍五入”法，即在尾数右移时，被移去的最高数值为0，则舍去；被移去的最高数值为1，则在尾数的末位加1.这样可能会使尾数又溢出，此时需要再做一次右规。



恒置1法：尾数右移时，不论丢掉的最高数值位是1还是0，都使右移后的尾数末位恒置1。这种方法同样有使尾数变大和变小的两种可能。



#### 强制类型转换

| 类型      | 16位机器 | 32位机器 | 64位机器 |
| --------- | -------- | -------- | -------- |
| char      | 8        | 8        | 8        |
| short     | 16       | 16       | 16       |
| int       | 16       | 32       | 32       |
| long      | 32       | 32       | 64       |
| long long | 64       | 64       | 64       |
| float     | 16       | 32       | 32       |
| double    | 64       | 64       | 64       |

###### 无损转换

char &rarr; int &rarr; long &rarr; double

float &rarr;  double

范围、精度从小到大，转换过程没有损失

###### 有损转换

int &rarr; float 可能损失精度

float &rarr; int 可能溢出及损失精度



## 电路的基本原理、加法器设计

ALU的作用：

- 算数运算：加、减、乘、除等
- 逻辑运算：与、或、非、异或等
- 辅助功能：移位、求补等





## 主存简单模型和寻址概念

### 主存储器

存储体

MAR

MDR



地址线：

数据线：



K：2<sup>10</sup>

M：2<sup>20</sup>

G：2<sup>30</sup>

T：2<sup>40</sup>



常见的描述：

8K x 8位的存储芯片，即2<sup>13</sup> x 8bit，有13根地址线，8根数据线。



#### 寻址

按照不同大小的单元来切分整个存储器，总共可以切成多少份。



假设总容量位1KB

按字节寻址：1K个存储单元，每个单元1B

按字寻址：256个存储单元，每个单元4B

按半字寻址：512个存储单元，每个单元2B

按双字寻址：128个存储单元，每个单元8B



## 半导体存储器RAM

### 半导体存储芯片的基本结构

##### 存储矩阵

由大量相同的位存储单元阵列构成。

##### 译码驱动

将来自地址总线的地址信号翻译成对应存储单元的选通信号，该信号在读写电路的配合下完成对被选中单元的读/写操作。

##### 读写电路

包括读出放大器和写入电路，用来完成读/写操作。



##### 读/写控制线

决定芯片进行读/写操作。读写共用一根线，或者分开两根线。

##### 片选线

确定哪个存储芯片被选中。可用于容量扩充。

##### 地址线

是单向输入的，其位数与存储字的个数有关。

###### 数据线

是双向的，其位数与读写或写入的数据位数有关。



### 半导体随机存取器

| 类型         | SRAM（Static Random Access Memory）静态随机存储器 | DRAM（Dynamic Random Access Memory）动态随机存储器 | 备注                                                      |
| ------------ | ------------------------------------------------- | -------------------------------------------------- | --------------------------------------------------------- |
| 存储信息0，1 | 触发器，双稳态                                    | 电容，充放电                                       | DRAM都以电信号的形式存储0/1，断电就丢失信息：易失性存储器 |
| 破坏性读出   | 非，读：查看触发器状态，写：改变触发器状态        | 是，读：连接电容，检测电流变化，写：给电容充/放电  | DRAM读出后需要重新充电                                    |
| 需要刷新     | 不要，能保持两种稳定的状态                        | 需要，电容上的电荷只能维持2ms                      |                                                           |
| 送行列地址   | 同时送                                            | 分两次送                                           | DRAM地址线可以复用，线数减少一半                          |
| 运行速度     | 快                                                | 慢                                                 |                                                           |
| 集成度       | 低，6个逻辑元件构成                               | 高，1个或3个逻辑元件构成                           |                                                           |
| 发热量       | 大                                                | 小                                                 |                                                           |
| 存储成本     | 高                                                | 低                                                 |                                                           |
| 应用         | 常用作Cache                                       | 常用作主存                                         |                                                           |



### DRAM的刷新

###### 多久刷新一次？

一般为2ms

###### 每次刷新多少存储单元

以行为单位，每次刷新一行存储单元。

使用行列地址，可以减少选通线的数量

###### 如何刷新

有硬件支持，读出一行的信息后重新写入，占用1个读/写周期

###### 在什么时候刷新

假设DRAM内部结构排列成128x128的形式，读/写周期（存取周期）0.5us。

方案一：分散刷新

每次读写完都刷新一行，系统的存取周期变为1us，前0.5us时间用于正常读写，后0.5us时间用于刷新某行

方案二：集中刷新

2ms内集中安排时间全部刷新，系统的存取周期还是0.5us，由于有一段时间专门用于刷新，造成无法访问存储器，称为访存“死区”。

方案三：异步刷新

2ms内每行刷新1次即可，2ms内需要产生128次刷新请求，每隔2ms/128=15.6us一次，每15.6us内有0.5us的“死时间”。



#### RAM的存储周期

启动存取						存取完					下次存取

​					存取时间					恢复时间

​									存取周期



## 半导体存储器ROM

### RAM易失性存储器

主存储器RAM：存储指令和数据

CPU：自动到主存中取指令；按指令的指示进行下一步工作。

ROM：保存固定的信息



### ROM（Read Only Memory）非易失性存储器

#### 发展历程

掩膜式只读存储器（MROM）：

​	存储内容由半导体制造厂按用户提出的要求在芯片的生产过程中直接写入，无法修改。

一次可编程只读存储器（PROM）

​	存储内容由用户用专门的设备（编程器）一次性写入，之后无法修改。

可擦除可编程只读存储器（EPROM）

​	紫外线擦除，电擦除，修改次数有限，写入时间很长。

闪速存储器（Flash Memory）

​	如U盘，写入速度较快。

固态硬盘（Solid State Drives）

​	控制单元+FLASH芯片。



## 存储器基本概念

### 按存储介质分类

磁芯存储器

磁表面存储器，磁盘，磁带

半导体存储器

光存储器



### 存储器的层次化结构

CPU	&hArr; 	Cache	&hArr;	主存	&hArr;	辅存

高速缓存为了解决CPU和主存速度不匹配的问题

辅存为了解决存储容量不够大的问题



## 主存与CPU的连接

译码器



### 主容量拓展

#### 位拓展

#### 字拓展

线选法

译码片选法



## 双口RAM和多模块存储器

### 双端口RAM

了解即可

### 多模块存储器

#### 单体多字存储器

多个普通存储器构成，每个存储单元存储m个字，总线宽度也为m个字，一次并行读出m个字

指令和数据在主存内必须是连续存放的。



#### 多体并行存储器

每个模块都有相同的容量和存取速度。

各个模块都有独立的读写控制电路、地址寄存器和数据寄存器。

它们既能并行工作，又能交叉工作。



##### 高位交叉编址模式

每个存储体存储周期为T

竖向编址

连续取n个存储字，耗时nT

##### 低位交叉编址模式

横向编址

连续取n个存储字，耗时T+(n-1) $\tau$



如：

模块数m=4，存储周期为T，字长为W，数据总线宽度为W，总线传输周期为r，连续存取n个字，求交叉存储器的带宽。

分析：

有m个存储体，存储周期为T，字长为W，每隔r时间启动下一个存储体，连续存取n个字，求存储器的存储速率。

连续存取n个字耗时 = T+(n-1)r，m > T/r
$$
带宽 = \frac {nW} {T+(n-1)r}
$$
当n足够大时，带宽 = W / r





## 高速缓冲存储器

命中率：CPU欲访问的信息已在Cache中的比率。

设一个程序执行期间，Cache的总命中次数为N<sub>c</sub>，访问主存的总次数为N<sub>m</sub>，则命中率：
$$
H = \frac {N_c} {N_c + N_m}
$$
缺失率：M = 1 - H



例子：

假设Cache的速度时主存的5倍，且Cache的命中率为95%，则采用Cache后，存储器性能提高多少（设Cache和主主存同时被访问，若Cache命中则中断访问主存）？

解：

设Cache的存取周期为t，则主存的存取周期为5t

Cache和主存同时访问，不命中时访问时间为5t

故系统的平均访问时间为T<sub>a</sub> = 0.95 x t + 0.05 x 5t = 1.2t

设每个周期可存取的数据量为S，

则存储系统的带宽为S/1.2t，

不采用Cache时的带宽为S/5t，

故性能为原来的 (S/1.2t) / (S/5t) = 5t / 1.2t = 4.17倍，即提高了3.17倍。

系统效率 e = t / 1.2t = 83.3%



## Cache-地址映射

### 全相联映射

空位随意放

主存字块标记 + 字块内地址

### 直接映射

对号入座

主存字块标记 + Cache字块地址 + 字块内地址

### 组相联映射

按号分组

主存字块标记 + 组地址 + 字块内地址



## Cache替换算法及写策略

### 替换算法

#### 随机算法（RAND）

随机的确定替换的Cache。它的实现比较简单，但没有依据程序访问的局部性原理，故可能命中率较低。

#### 先进先出算法（FIFO，First In First Out）

选择最早调入的进行替换，它比较容易实现，但也没有依据程序访问的局部性原理，可能会把一些需要经常使用的程序块（如循环程序）也作为最早进入Cache的块替换掉。

#### 近期最少使用算法（LRU，Least Recently Used）

依据程序访问的局部性原理选择近期内长久未访问的存储行作为替换的行，平均命中率要比FIFO要高，是堆栈类算法。LRU算法对每行设置一个计数器，Cache每命中一次，命中行计数器清0，而其他各行计数器均加1，需要替换时比较各特定行的技术值，将技术值最大的行换出。

#### 最不经常使用算法（LFU）

将一段时间内被访问次数最少的存储行换出。每行也设置一个计数器，新行建立后从0开始计数，每访问一次，被访问的行计数器加1，需要替换时比较各特定行的计数值，将计数值最小的行换出。



### 写策略

#### 写回法搭配写分配法



#### 全写法搭配非写分配法



#### 多级Cache



## 虚拟存储器

虚拟存储器是一个逻辑模型

功能：用户给出一个地址，叫做虚地址或逻辑地址，虚拟存储器要给出该地址对应的数据。

实现：由辅助硬件将虚地址映射到主存当中的某个单元，主存单元地址称为实地址或物理地址。



### 页式虚拟存储器

虚拟空间与主存空间都被划分成同样大小的页，主存的页称为实页，虚存的页称为虚页。

虚地址结构：虚页号+页内地址

实地址结构：实页号+页内地址



虚页号到实页的映射号通过一张页表实现。



#### 页表基址寄存器

负责存储页表起始地址。

页表起始地址和虚页号进行拼接得到页表项地址。

页表项地址指向虚页号对应的实页号所在位置。



### 段式虚拟存储器

段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。

虚拟地址分为两部分：段号和段内地址。

段表：每一行记录了与某个段对应的段号、装入位、段起点和段长等信息。

由于段的长度可变，所以段表中要给出各段的起始地址与段的长度。

虚地址结构：段号+段内地址

实地址结构：主存地址



#### 段表基址寄存器

负责存储段表起始地址。

段表起始地址和段号进行拼接得到页表项地址。

段表项地址与段内地址相加得到虚地址对应的主存地址。



## 指令系统

### 指令的定义

指令（又称机器指令），是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。

一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。



注：

一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。



### 指令的格式

一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。

一条指令通常要包括操作码字段和地址码字段两部分：

一条指令的结构：

操作码（OP）+ 地址码（A）



###### 操作码的功能：

用户要干什么？

停机中断

求反求补

加减乘除

...



###### 地址码的功能：

对谁进行操作？

不需要操作对象

需要一个操作对象

...



例子：设指令字长及存储字长均为32位，操作码占8位。

#### 四地址指令

| OP   | A<sub>1</sub> | A<sub>2</sub> | A<sub>3</sub>(结果) | A<sub>4</sub>（下址） |
| ---- | ------------- | ------------- | ------------------- | --------------------- |

指令含义：

（A<sub>1</sub>）OP（A<sub>2</sub>）&rarr;	A<sub>3</sub>，A<sub>4</sub> = 下一条将要执行指令的地址。

4个地址码字段各占6位，指令操作数直接寻址范围为2<sup>6</sup> = 64；完成一条指令需要访存4次。



####  三地址指令

| OP   | A<sub>1</sub> | A<sub>2</sub> | A<sub>3</sub>(结果) |
| ---- | ------------- | ------------- | ------------------- |

引入程序计数器PC，执行一条指令后自动执行下一条指令。

指令含义：

（A<sub>1</sub>）OP（A<sub>2</sub>）&rarr;	A<sub>3</sub>

3个地址码字段各占8位，指令操作数直接寻址范围为2<sup>8</sup> = 256；完成一条指令需要访存4次。



####  二地址指令

| OP   | A<sub>1</sub>（目的操作数） | A<sub>2</sub>（源操作数） |
| ---- | --------------------------- | ------------------------- |

指令含义：

（A<sub>1</sub>）OP（A<sub>2</sub>）&rarr;	A<sub>1</sub>

2个地址码字段各占12位，指令操作数直接寻址范围为2<sup>12</sup> = 4K；完成一条指令需要访存4次。



####  一地址指令

| OP   | A<sub>1</sub> |
| ---- | ------------- |

指令含义：

1. OP（A<sub>1</sub>）&rarr;	A<sub>1</sub>，如加1、减1、取反、求补等，完成一条指令需要访存3次。
2. （ACC）OP（A<sub>1</sub>）&rarr;  ACC，隐含约定目的地址为ACC，完成一条指令需要访存2次。

1个地址码字段各占24位，指令操作数直接寻址范围为2<sup>24</sup> = 16M。



####  零地址指令

| OP   |
| ---- |

指令含义：

1. 不需要操作数，如空操作、停机、关中断等指令。
2. 堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶。



#### 指令分类

###### 按整条指令的长度分类

定长指令字结构：指令长度固定。

变长指令字结构：指令长度不等。



###### 按操作码的长度分类

定长操作码：n位 &rarr; 2<sup>n</sup>条指令。

扩展操作码：操作码长度可变。



### 扩展操作码

基本结构：

| OP   | A<sub>1</sub> | A<sub>2</sub> | A3   |
| ---- | ------------- | ------------- | ---- |



设指令字长为16位：

前4位为基本操作码字段OP，另有3个4位长的地址字段A<sub>1</sub>、A<sub>2</sub>和A<sub>3</sub>。



4位基本操作码若全部用于三地址指令，则有16条。

但至少须将1111留作扩展操作码之用，即三地址指令为15条；

1111 1111留作扩展操作码之用，二地址指令为15条；

1111 1111 1111 留作扩展操作码之用，一地址指令为15条；

零地址指令为16条。



### 操作类型

#### 数据传送

LOAD作用：把存储器中的数据放到寄存器中。

STORE作用：把寄存器中的数据放到存储器中。



#### 算术逻辑操作

算术：加、减、乘、除、增1、减1、求补、浮点运算、十进制运算

逻辑：与、或、非、异或、位操组、位测试、位清除、位求反



#### 移位操作

算术移位、逻辑移位、循环移位（带进位和不带进位）



#### 转移操作

无条件转移：JMP

条件转移：JZ，结果为0，JO：结果溢出，JC：结果有进位

调用和返回CALL和RETURN

陷阱（Trap）与陷阱指令



#### 输入输出操作

CPU寄存器与IO端口之间的数据传送（端口即IO接口中的寄存器）





## 指令寻址

### 数据存放

#### 按字节编址

每个字节存储单元都有一个地址编号，一个格子为一个字节

| 0    | 1    | 2    | 3    |
| ---- | ---- | ---- | ---- |
| 4    | 5    | 6    | 7    |
| 8    | 9    | 10   | 11   |
| 12   | 13   | 14   | 15   |
| 16   | 17   | 18   | 19   |
| 20   | 21   | 22   | 23   |
| 24   | 25   | 26   | 27   |



###### 按字节地址寻址

以一个格子为一个存储单元，称为字节存储单元。

按字节地址寻址：给出一个字节地址，可以取出长度为一个字节的数据。

假设某数据长度为4B，则需要给出4个字节地址。



###### 按字地址寻址

以4个格子为一个存储单元，称为字存储单元。

按字地址寻址：给出一个字地址，可以取出长度为一个字的数据。

字地址：

0～3为一个字，4～7为一个字...，每个字中最小的字节地址为字地址。

假设某数据长度为4B，则需要给出1个字地址。



#### 按字编址

4个字节为一个存储单元来编号



#### 数据存放方式

大端方式：数据的高位存放在存储单元的低地址部分。

小端方式：数据的低位存放在存储单元的低地址部分。



#### 三个字长

机器字长：CPU一次能处理的二进制数据的位数。

指令字长：一个指令字中包含二进制代码的位数。

	- 单字长指令：指令长度 = 机器字长
	- 半字长指令：指令长度 = 机器字长/2
	- 双字长指令：指令长度 = 机器字长*2

存储字长：一个存储单元存储二进制代码的长度。



#### 边界对齐存储

起始地址是字长（按字节算）的整数倍。



### 指令寻址

下一条欲执行指令的指令地址，始终由程序计数器PC给出。



#### 顺序寻址

（PC）+1  &rarr;  PC



#### 跳跃寻址

由转移指令指出



举例：

| 指令地址 | 操作码 | 地址码 | PC（默认指向第一条地址0）    |
| -------- | ------ | ------ | ---------------------------- |
| 0        | LDA    | 1000   | 执行完后自动+1，变为1        |
| 1        | ADD    | 1001   | 2                            |
| 2        | DEC    | 1200   | 3                            |
| 3        | JMP    | 7      | 将PC指向7，跳到第7条指令执行 |
| 4        | LDA    | 2000   |                              |
| 5        | SUB    | 2001   |                              |
| 6        | INC    |        |                              |
| 7        | LDA    | 1100   |                              |
|          | ...    |        |                              |



### 数据寻址

确定本条指令的操组数地址



#### 操作数类型

地址：无符号数

数字：定点数、浮点数、十进制数

字符：ASCII码

逻辑数：逻辑运算



#### 寻址方式

| 0000 隐含寻址   | 0001 立即寻址       | 0010 直接寻址 | 0011 间接寻址 |
| --------------- | ------------------- | ------------- | ------------- |
| 0100 寄存器寻址 | 0101 寄存器间接寻址 | 0110 相对寻址 | 0111 基础寻址 |
| 1000 变址寻址   | 1001 堆栈寻址       |               |               |



#### 组成

##### 一地址指令

| 操作码（OP） | 寻址特征 | 形式地址（A） |
| ------------ | -------- | ------------- |

操作数的真实地址称为EA。



假设指令字长 = 机器字长 = 存储字长，假设操作数为3



##### 立即寻址

形式地址A就是操作数本身，又称为立即数，一般采用补码形式。#号表示立即寻址特征。

优点：指令执行阶段不访问主存，指令执行时间最短。

缺点：A的位数限制了立即数的范围，如A的位数为n，且立即数采用补码时，可表示的数据范围为-2<sup>n-1</sup> ~ 2<sup>n-1</sup> - 1。



###### 访存次数

取指令，访存1次

执行指令，访存0次

不考虑存结果，共访存1次。



#### 直接寻址

指令中的形式地址A就是操组数的真实地址EA，即EA=A。



优点：简单，指令执行阶段仅访问一次主存，不需要专门计算操作数地址。

缺点：

- A的位数决定了该指令操作数的寻址范围；操作数的地址不易修改。



###### 访存次数

取指令，访存1次

执行指令，访存1次

不考虑存结果，共访存2次。



#### 间接寻址

指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数的有效地址所在的存储单元的地址，也就是操作数地址的地址，即EA=(A)。



又可分为一次间址和两次间址



优点：

- 可扩大寻址范围（有效地址EA的位数大于形式地址A的位数）。
- 便于编制程序（用间接寻址可以方便的完成子程序返回）。

缺点：指令在执行阶段要多次访存（一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存）。



###### 访存次数

一次间址

取指令，访存1次

执行指令，访存2次

不考虑存结果，共访存3次。



#### 寄存器寻址

在指令字中直接给出操组数所在的寄存器编号，即EA=R<sub>i</sub>，其操作数在由R<sub>i</sub>所指的寄存器内。



优点：

- 指令在执行阶段不访问主存，只访问寄存器。
- 指令字短且执行速度快，支持向量/矩阵运算。

缺点：寄存器价格昂贵，计算机中寄存器个数有限。



###### 访存次数

取指令，访存1次

执行指令，访存0次

不考虑存结果，共访存1次。



#### 寄存器间接寻址

寄存器R<sub>i</sub>中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=(R<sub>i</sub>)。



特点：与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中）。



###### 访存次数

取指令，访存1次

执行指令，访存1次

不考虑存结果，共访存2次。



#### 隐含寻址

不是明显的给出操作数地址，而是在指令中隐含着操组数的地址。



优点：有利于缩短指令字长。

缺点：需增加存储操组数或隐含地址的硬件。

​                     

### 数据寻址-偏移寻址

#### 基址寻址

将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即EA=(BR)+A。

- 采用专用寄存器BR作为基址寄存器
- 采用通用寄存器作为基址寄存器

基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定。在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。当采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统决定。

优点：可扩大寻址范围（基址寄存器的位数大于形式地址A的位数）；用户不必考虑自己的程序存于主存的哪一个空间区域，故有利于多道程序设计，以及可用于编制浮动程序。



#### 变址寻址

有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和，即EA=(IX)+A，其中IX为变址寄存器（专用），也可用通用寄存器作为变址寄存器。

变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基础）。

优点：可扩大寻址范围（变址寄存器的位数大于形式地址A的位数）；在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。

变址寻址与基址寻址配合使用：EA=A+(BR)+(IX)

变址寻址与间接寻址配合使用：

EA=(A+(IX))，先变址后间址；

EA=(A)+(IX)，先间址后变址。



#### 相对寻址

把程序计数器PC的内容加上指令格式中的形式地址A而形成操组数的有效地址，即EA=(PC)+A，其中A是相对于当前指令地址的位移量，可正可负，补码表示。

优点：操组数的地址不是固定的，它随着PC值的变化而变化，并且指令地址之间总是相差一个固定值，因此便于程序浮动。

相对寻址广泛应用于转移指令。



### 数据寻址-堆栈寻址

操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操组数地址。

堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出（LIFO）”原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）。





## CISC和RISC替换版

### CISC（Complex Instruction Set Computer）

设计思路：一条指令完成一个复杂的基本功能。

代表：x86架构，主要用于笔记本、台式机等。



80-20规律：典型程序中80%的语句仅仅使用处理机中20%的指令，所以诞生RISC



### RISC（Reduced Instruction Set Computer）

设计思路：一条指令完成一个基本“动作”，多条指令组合完成一个复杂的基本功能。

代表：ARM架构，主要用于手机、平板等。

| 类别             | CISC                                 | RISC                                 |
| ---------------- | ------------------------------------ | ------------------------------------ |
| 指令系统高       | 复杂，庞大                           | 简单，精简                           |
| 指令数目         | 一般大于200条                        | 一般小于100条                        |
| 指令字长         | 不固定                               | 定长                                 |
| 可访存指令       | 不加限制                             | 只有LOAD/STORE指令                   |
| 各种指令执行时间 | 相差较大                             | 绝大多数在一个周期内完成             |
| 各种指令使用频度 | 相差很大                             | 都比较常用                           |
| 通用寄存器数量   | 较少                                 | 多                                   |
| 目标代码         | 难以用优化编译生成高效的目标代码程序 | 采用优化的编译程序，生成代码较为高效 |
| 控制方式         | 绝大多数为微程序控制                 | 绝大多数为组合逻辑控制               |
| 指令流水线       | 可以通过一定方式实现                 | 必须实现                             |



## 中央处理器

### CPU的功能和结构

#### CPU的功能

1. 指令控制：完成取指令、分析指令和执行指令的操作，即程序的顺序控制。
2. 操作控制：一条指令的功能往往是由若干操作信号的组合来实现的。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。
3. 时间控制：对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。
4. 数据加工：对数据进行算术和逻辑运算。
5. 中断处理：对计算机运行过程中出现的异常情况和特殊请求进行处理。



###### 运算器

对数据进行加工

###### 控制器

协调并控制计算机各部件执行程序的指令序列，基本功能包括取指令、分析指令、执行指令。



取指令：自动形成指令地址；自动发出取指令的命令。

分析指令：操作码译码（分析本条指令要完成什么操作）；产生操作数的有效地址。

执行指令：根据分析指令得到的“操作命令”和“操作数地址”，形成操作信号控制序列，控制运算器、存储器以及IO设备完成相应的操作。

中断处理：管理总线及输入输出；处理异常情况（如掉电）和特殊请求（如打印机请求打印一行字符）。



#### 运算器的基本结构

算术逻辑单元：主要功能是进行算术和逻辑运算。

通用寄存器：用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。

暂存寄存器：用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容。

累加寄存器：它是一个通用寄存器，用于暂时存放ALU运算的结果信息，用于实现加法运算。

程序状态字寄存器：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志（OP）、符号标志（SF）、零标志（ZF）、进位标志（CF）等。PSW中的这些位参与并决定微操作的形成。

移位器：对运算结果进行移位运算。

计数器：控制乘除运算的操作步数。



###### 专用数据通路方式

根据指令执行过程中的数据和地址的流动方向安排连接线路。

优点：

性能较高，基本不存在数据冲突现象，但结构复杂，硬件量大，不易实现。



方案一：

使用多路选择器根据控制信号选择一路输出。



方案二：

使用三态门可以控制每一路是否输出。



###### CPU内部单总线方式

将所有寄存器的输入端和输出端都连接到一条公共的通路上。

优点：

结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低。



### 运算器的基本结构

程序计数器：用于指出下一条指令在主存中存放地址。CPU就是根据PC的内容去主存中取指令的。因程序中指令（通常）是顺序执行的，所以PC有自增功能。

指令寄存器：用于保存当前正在执行的那条指令。

指令译码器：仅对操作码字段进行译码，向控制器提供特定的操作信号。

微操作信号发生器：根据IR的内容（指令）、PSW的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。

时序系统：用于产生各种时序信号，它们都是由统一时钟（CLOCK）分频得到。

存储地址寄存器：用于存放所要访问的主存单元的地址。

存储器数据寄存器：用于存放向主存写入的信息或从主存中读出的信息。



#### CPU基本结构

ALU

寄存器

中断系统

CU



### 指令执行过程

指令周期：CPU从主存中每取出并执行一条指令所需的全部时间。

指令周期常常用若干机器周期来表示，机器周期又叫CPU周期。

一个机器周期又包含若干始终周期（也称为节拍、T周期或CPU时钟周期，它是CPU操作的最基本单位）。

每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数也可以不等。



#### 指令周期流程

取指周期：取指令

间址周期：取有效地址

执行周期：取操作数

中断周期：保护程序断点

四个周期都有CPU访存操作，只是访问的目的不同。

CLK触发器，判断处在哪一个周期。



##### 取指周期的数据流

1. 当前指令地址送至存储器地址寄存器，记做：(PC)	&rarr;	MAR
2. CU发出控制信号，记控制总线传到主存，这里是读信号，记做：1&rarr;R
3. 将MAR所指主存中的内容经数据总线送入MDR，记做：M(MAR)&rarr;MDR
4. 将MDR中的内容（此时是指令）送入IR，记做：(MDR)&rarr;IR
5. CU发出控制信号，形成下一条指令地址，记做：(PC)+1&rarr;PC



##### 间址周期的数据流

1. 将指令的地址码送入MAR，记做：Ad(IR)&rarr;MAR 或 Ad(MDR)&rarr;MAR
2. CU发出控制信号，启动主存做读操作，记做：1&rarr;R
3. 将MAR所指主存中的内容经数据总线送入MDR，记做：M(MAR)&rarr;MDR
4. 将有效地址送至指令的地址码字段，记做：MDR&rarr;Ad(IR)



##### 执行周期的数据流

执行周期的任务是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。



##### 中断周期的数据流

中断：暂停当前任务去完成其他任务。为了能够恢复当前任务，需要保存断点。一般使用堆栈来保存断点，这里用SP表示栈顶地址，假设SP指向栈顶元素，进栈操作是先修改指针，后存入数据。

1. CU控制将SP减1，修改后的地址送入MAR，记做：(SP)-1 &rarr; SP，(SP)&rarr;MAR，本质上是将断点存入某个存储单元，假设其地址为a，故可记做：a&rarr;MAR
2. CU发出控制信号，启动主存做写操作，记做：1 &rarr; W
3. 将断点(PC内容)送入MDR，记做：(PC) &rarr; MDR
4. CU控制将中断服务程序的入口地址（由向量地址形成部件产生）送入PC，记做：向量地址&rarr;PC



###### 指令执行方案

一个指令周期通常要包括几个时间段（执行步骤），每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。

方案一：单指令周期

对所有指令都选用相同的执行时间来完成。

指令之间串行执行；指令周期取决于执行时间最长的指令的执行时间。

对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度。



方案二：多指令周期

对不同类型的指令选用不同的执行步骤来完成。

指令之间串行执行；可选用不同个数的时钟周期来完成不同指令的执行过程。

需要更复杂的硬件设计。



方案三：流水线方案

在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。

指令之间并行执行。



### 数据通路的功能和基本结构单总线

数据通路：数据在功能部件之间传送的路径。

信息从哪里开始中间经过哪些部件最后传到哪里。

由控制部件产生的控制信号建立数据通路。

数据通路的基本结构：

- CPU内部单总线方式
- CPU内部多总线方式
- 专用数据通路方式



#### CPU内部单总线方式

内部总线：

是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线。

系统总线：

是指同一台计算机系统的各部件，如CPU、内存、通道和各类I/O接口间互相连接的总线。



##### 寄存器之间的数据传送

比如把PC内容送至MAR，实现传送操作的流程及控制信号为：

(PC) &rarr; Bus，PC<sub>out</sub>有效，PC内容送总线

Bus &rarr; MAR，MAR<sub>in</sub>有效，总线内容送MAR



##### 主存与CPU之间的数据传送

比如CPU从主存读取指令，实现传送操作的流程及控制信号为：

(PC) &rarr; Bus &rarr; MAR，PC<sub>out</sub>和MAR<sub>in</sub>有效，现行指令地址 &rarr; MAR

1 &rarr; R，CU发读命令

MEM(MAR) &rarr; MDR，MDR<sub>in</sub>有效

MDR &rarr; Bus &rarr; IR，MDR<sub>out</sub>和IR<sub>in</sub>有效，现行指令 &rarr; IR



##### 执行算术或逻辑运算

比如一条加法指令，微操作序列及控制信号为：

Ad(IR) &rarr; Bus &rarr; MAR，MDR<sub>out</sub>和MAR<sub>in</sub>有效

1 &rarr; R，CU发读命令

MEM(MAR) &rarr; 数据线 &rarr; MDR，MDR<sub>in</sub>有效

MDR &rarr; Bus &rarr; Y，MDR<sub>out</sub>和Y<sub>in</sub>有效，操作数 &rarr; Y

(ACC) + (Y) &rarr; Z，ACC<sub>out</sub>和ALU<sub>in</sub>有效，CU向ALU发送加命令

Z &rarr; ACC，Z<sub>out</sub>和ACC<sub>in</sub>有效，结果 &rarr; ACC



例子：设有如图所示的单总线结构，分析指令ADD(R0)，R1的指令流程和控制信号。

1. 分析指令功能和指令周期

   功能：((R0)) + (R1) &rarr; (R0)

   取指周期、间址周期、执行周期

2. 写出各阶段的指令流程

取指周期：公共操作

| 时序 | 微操作            | 有效控制信号                               |
| ---- | ----------------- | ------------------------------------------ |
| 1    | (PC) &rarr; MAR   | PC<sub>out</sub>，MAR<sub>in</sub>         |
| 2    | M(MAR) &rarr; MDR | MemR，MAR<sub>out</sub>，MDR<sub>in</sub>E |
| 3    | (MDR) &rarr; IR   | MDR<sub>out</sub>，IR<sub>in</sub>         |
| 4    | 指令译码          | -                                          |
| 5    | (PC) +1 &rarr; PC | -                                          |

间址周期：完成取数操作，被加数在主存中，加数已经放在寄存器R1中。

| 时序 | 微操作            | 有效控制信号                               |
| ---- | ----------------- | ------------------------------------------ |
| 1    | (R0) &rarr; MAR   | R0<sub>out</sub>，MAR<sub>in</sub>         |
| 2    | M(MAR) &rarr; MDR | MemR，MAR<sub>out</sub>，MDR<sub>in</sub>E |
| 3    | (MDR) &rarr; Y    | MDR<sub>out</sub>，Y<sub>in</sub>          |

执行周期：相加操作

| 时序 | 微操作              | 有效控制信号                                             |
| ---- | ------------------- | -------------------------------------------------------- |
| 1    | (R1) + (Y) &rarr; Z | R1<sub>out</sub>，ALU<sub>in</sub>，CU向ALU发ADD控制信号 |
| 2    | (Z) &rarr; MDR      | Z<sub>out</sub>，MDR<sub>in</sub>                        |
| 3    | (MDR) &rarr; M(MAR) | MemW，MDR<sub>out</sub>E，MAR<sub>out</sub>              |



### 数据通路的功能和基本结构专用通路

#### 取指周期

(PC) &rarr; MAR

(MAR) &rarr; 主存

1 &rarr; R，控制单元向主存发送读命令

M(MAR) &rarr; MDR

(MDR) &rarr; IR

(PC) + 1 &rarr; PC

Op(IR) &rarr; CU



### 控制器的功能和工作原理-硬布线

地址总线（AB）：内存储器、输入设备和输出设备从地址总线接收地址信息。

控制总线（CB）：内存储器、输入设备和输出设备从控制总线得到控制信号。

数据总线（DB）：内存储器、输入设备和输出设备通过数据总线与其他部件传送数据。

输入设备和输出设备通过接口电路与总线相连。

运算器部件通过数据总线与内存储器、输入设备和输出设备传送数据。

控制器部件送出指令地址到地址总线。

控制器部件从数据总线接收指令信息。

控制器部件向系统中的部件提供它们运行所需要的控制信号。



#### 控制器的结构和功能

控制器是计算机系统的指挥中心，控制器的主要功能有：

1. 从主存中取出一条指令，并指出下一条指令在主存中的位置。
2. 对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。
3. 指挥并控制CPU、主存、输入和输出设备之间的数据流动方向。

简称：取指令、分析指令、执行指令。



#### 控制单元的输入和输出



​							指令寄存器IR

​									&darr;

标志，时钟 &rarr; 控制单元CU &larr; 系统总线

​									&uarr;

​							CPU内部控制信号



##### 输入

- 指令寄存器OP(IR) &rarr; CU

  控制信号的产生与操作码有关

- 时钟

  一个时钟脉冲发出一个操作命令或一组需要同时执行的操作命令。

- 标志

  如条件转移指令，根据相应的标志位决定下一步操作。

- 外来信号

  如：中断请求信号INTR

  ​		总线请求信号HRQ

##### 输出

- CPU内部的控制信号

  寄存器之间的数据传输、PC的修改、控制ALU进行的运算

- 到控制总线的控制信号

  到存储器：访存控制信号$\overline{MREQ}$、读命令$\overline{RD}$、写命令$\overline{WR}$

  到I/O设备：访问I/O设备的控制信号$\overline{IO}$

  中断响应信号INTA、总线响应信号HLDA



CU的设计：

1. 硬布线（组合逻辑电路+触发器）
2. 微程序



#### 硬布线控制器



​																		指令寄存器IR

​																				&darr;

​																		操作码译码器

​																				&darr;

​		机器主频（CLK）&rarr;	节拍发生器 &rarr; 控制单元CU &larr; 标志（来自执行单元的反馈信息）

​																				&uarr;

​																	CPU内部控制信号



设计步骤：

1. 分析每个阶段的微操作序列
2. 选择CPU的控制方式
3. 安排微操作时序
4. 电路设计



#### CPU的控制方式

CPU控制方式：产生不同微操作命令序列所用的时序控制方式。

##### 同步控制方式

整个系统所有的控制信号均来自一个统一的时钟信号。

通常以最长的微操作序列和最繁琐的微操作作为标准，采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令。

同步控制方式的优点是控制电路简单，缺点是运行速度慢。

##### 异步控制方式

异步控制方式不存在基准时标信号。

各部件按自身固有的速度工作，通过应答方式进行联络。

异步控制方式的优点是运行速度快，缺点是控制电路比较复杂。

##### 联合控制方式

对各种不同的指令的微操作实行大部分采用同步控制、小部分采用异步控制方法。



#### 安排操作时序的原则

##### 原则一

微操作的先后顺序不得随意更改。

##### 原则二

被控对象不同的微操作尽量安排在一个节拍内完成。

##### 原则三

占用时间较短的微操作尽量安排在一个节拍内完成，并允许有先后顺序。



#### 安排操作时序

##### 取指周期

| 周期          | 时序及内容             | 备注       |
| ------------- | ---------------------- | ---------- |
| T<sub>0</sub> | (1) PC &rarr; MAR      |            |
| T<sub>0</sub> | (2) 1 &rarr; R         | 发出读信号 |
| T<sub>1</sub> | (3) M(MAR) &rarr; MDR  | 在(1)之后  |
| T<sub>1</sub> | (6) (PC) + 1 &rarr; PC | 在(1)之后  |
| T<sub>2</sub> | (4) MDR&rarr; IR       | 在(3)之后  |
| T<sub>2</sub> | (5) OP(IR) &rarr; ID   | 在(4)之后  |



##### 间址周期

| 周期          | 时序及内容            | 备注 |
| ------------- | --------------------- | ---- |
| T<sub>0</sub> | (1) Ad(IR) &rarr; MAR |      |
| T<sub>0</sub> | (2) 1 &rarr; R        |      |
| T<sub>1</sub> | (3) M(MAR) &rarr; MDR |      |
| T<sub>2</sub> | (4) MDR&rarr; Ad(IR)  |      |



##### 执行周期

非访存指令

1. CLA（clear），ACC清零

   T<sub>0</sub> 

   T<sub>1</sub> 

   T<sub>2</sub>	0 &rarr; AC

2. COM（complement），ACC取反

   T<sub>0</sub> 

   T<sub>1</sub> 

   T<sub>2</sub>	&\overline{AC}& &rarr; AC

3. SHR（shift right），算术右移

   T<sub>0</sub> 

   T<sub>1</sub>	L(AC) &rarr; R(AC)

   T<sub>2</sub>	AC<sub>0</sub> &rarr; AC<sub>0</sub>

4. CSL（cycle shift left），循环左移

   T<sub>0</sub> 

   T<sub>1</sub> 

   T<sub>2</sub>	R(AC) &rarr; L(AC)，AC<sub>0</sub> &rarr; AC<sub>n</sub>

5. STP（stop），停机

   T<sub>0</sub> 

   T<sub>1</sub> 

   T<sub>2</sub>	0 &rarr; G



访存指令

1. ADD（add），加法指令，隐含ACC

   T<sub>0</sub>	Ad(IR) &rarr; MAR, 1 &rarr; R

   T<sub>1</sub>	M(MAR) &rarr; MDR

   T<sub>2</sub>	(AC) + (MDR) &rarr; AC

2. STA X（store acc），存数指令

   T<sub>0</sub>	Ad(IR) &rarr; MAR, 1 &rarr; W

   T<sub>1</sub>	AC &rarr; MDR

   T<sub>2</sub>	MDR &rarr; M(MAR)

3. LDA X（load acc），取数指令

   T<sub>0</sub>	Ad(IR) &rarr; MAR, 1 &rarr; R

   T<sub>1</sub>	M(MAR) &rarr; MDR

   T<sub>2</sub>	MDR &rarr; AC



转移指令

1. JMP X（jump），无条件转移

   T<sub>0</sub>	

   T<sub>1</sub> 

   T<sub>2</sub>	Ad(IR) &rarr; PC

2. BAN X（branch acc negative），条件转移

   T<sub>0</sub> 

   T<sub>1</sub> 

   T<sub>2</sub>	A<sub>0</sub>•Ad(IR) + $\overline{A_0}$•PC &rarr; PC



##### 中断周期

| 周期          | 时序及内容             | 备注       |
| ------------- | ---------------------- | ---------- |
| T<sub>0</sub> | (1) a &rarr; MAR       |            |
| T<sub>0</sub> | (2) 1 &rarr; W         | 发出写信号 |
| T<sub>1</sub> | (3) 0 &rarr; EINT      | 硬件关中断 |
| T<sub>1</sub> | (4) (PC) &rarr; MDR    |            |
| T<sub>2</sub> | (5) MDR&rarr; M(MAR)   | 在(4)之后  |
| T<sub>2</sub> | (6) 向量地址 &rarr; PC | 在(4)之后  |



#### 组合逻辑设计

设计步骤：

- 列出操作时间表
- 写出微操作命令的最简表达式
- 画出逻辑图

##### 列出操作时间表

| 工作周期 | 节拍          | 状态条件                         | 微操作                    | CLA  | COM  | SHR  | CSL  | STP  | ADD  | STA  | LDA  | JMP  | BAN  |
| -------- | ------------- | -------------------------------- | ------------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| FE取指   | T<sub>0</sub> |                                  | PC &rarr; MAR             | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
|          |               |                                  | 1 &rarr; R                | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
|          | T<sub>1</sub> |                                  | M(MAR) &rarr; MDR         | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
|          |               |                                  | (PC)+1 &rarr; PC          | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
|          | T<sub>2</sub> |                                  | MDR &rarr; IR             | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
|          |               |                                  | OP(IR) &rarr; ID          | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
|          |               | I(间址特征)                      | 1 &rarr; IND              |      |      |      |      |      | 1    | 1    | 1    | 1    | 1    |
|          |               | $\overline{I}$                   | 1 &rarr; EX               | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
| IND间址  | T<sub>0</sub> |                                  | Ad(IR) &rarr; MAR         |      |      |      |      |      | 1    | 1    | 1    | 1    | 1    |
|          |               |                                  | 1 &rarr; R                |      |      |      |      |      | 1    | 1    | 1    | 1    | 1    |
|          | T<sub>1</sub> |                                  | M(MAR) &rarr; MDR         |      |      |      |      |      | 1    | 1    | 1    | 1    | 1    |
|          | T<sub>2</sub> |                                  | MDR &rarr; Ad(IR)         |      |      |      |      |      | 1    | 1    | 1    | 1    | 1    |
|          |               | $\overline{IND}$（间址周期标志） | 1 &rarr; EX               |      |      |      |      |      | 1    | 1    | 1    | 1    | 1    |
| EX执行   | T<sub>0</sub> |                                  | Ad(IR) &rarr; MAR         |      |      |      |      |      | 1    | 1    | 1    |      |      |
|          |               |                                  | 1 &rarr; R                |      |      |      |      |      | 1    |      | 1    |      |      |
|          |               |                                  | 1 &rarr; W                |      |      |      |      |      |      | 1    |      |      |      |
|          | T<sub>1</sub> |                                  | M(MAR) &rarr; MDR         |      |      |      |      |      | 1    |      | 1    |      |      |
|          |               |                                  | AC &rarr; MDR             |      |      |      |      |      |      | 1    |      |      |      |
|          | T<sub>2</sub> |                                  | (AC)+(MDR) &rarr; AC      |      |      |      |      |      | 1    |      |      |      |      |
|          |               |                                  | MDR &rarr; M(MAR)         |      |      |      |      |      |      | 1    |      |      |      |
|          |               |                                  | MDR &rarr; AC             |      |      |      |      |      |      |      | 1    |      |      |
|          |               |                                  | 0 &rarr; AC               | 1    |      |      |      |      |      |      |      |      |      |
|          |               |                                  | $\overline{AC}$ &rarr; AC |      | 1    |      |      |      |      |      |      |      |      |
|          |               |                                  | Ad(IR) &rarr; PC          |      |      |      |      |      |      |      |      | 1    |      |
|          |               | A<sub>0</sub>                    | Ad(IR) &rarr; PC          |      |      |      |      |      |      |      |      |      | 1    |



##### 写出微操作命令的最简表达式

M(MAR) &rarr; MDR 微操作命令的逻辑表达式：

FE•T<sub>1</sub> + IND•T<sub>1</sub>(ADD+STA+LDA+JMP+BAN) + EX•T<sub>1</sub>(ADD+LDA)

= T<sub>1</sub>{FE+IND(ADD+STA+LDA+JMP+BAN)+EX(ADD+LDA)}



##### 画出逻辑图



#### 硬布线控制器小结

设计步骤：

1. 分析每个阶段的微操作序列
2. 选择CPU的控制方式
3. 安排微操作时序
4. 电路设计
   - 列出操作时间表
   - 写出微操作命令的最简表达式
   - 画出逻辑图



### 微程序

硬布线工作原理：微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即使产生。

微程序工作原理：事先把微操作控制信号存储在一个专门的存储器（控制存储器）中，将每一条机器指令编写成一个微程序，这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。



#### 微程序的基本思想

完成一条机器指令 

= 微操作命令1 + 微操作命令2+ ... + 微操作命令n

= 微指令1 + ... 微指令n

= 微指令



微操作命令，即微命令，是微操作的控制信号。微操作是微命令的执行过程。

相容性微命令：可以同时产生、共同完成某一些微操作的微命令。

互斥性微命令：在机器中不允许同时出现的微命令。



一条机器指令对应一个微程序。

微指令的基本格式 = 操作控制（微操作码） + 顺序控制（微地址码）



每条指令取指周期的操作是相同的，所以将取指操作的微命令统一编成一个微程序，而每条机器指令所对应的具体操作再单独编写一个对应的微程序。



#### 微程序控制器的基本结构

###### 控制存储器CM：

用于存放各指令对应的微程序，控制存储器可用只读存储器ROM构成。

###### 地址译码：

将地址码转化为存储单元控制信号。

###### CMAR：

微地址寄存器，接收微地址形成部件送来的微地址，为在CM中读取微指令作准备。

###### CMDR：

用于存放从CM中取出的微指令，它的位数同微指令字长相等。

###### 微指令形成部件：

产生初始微地址和后继微地址，以保证微指令的连续执行。

###### 顺序逻辑：

标志和CLK



##### 控制存储器

| M                | M+1  | 取指周期微程序  |
| ---------------- | ---- | --------------- |
| M+1              | M+2  | 取指周期微程序  |
| M+2              | M+3  |                 |
| ...              |      | 间址周期微程序  |
| 转执行周期微指令 |      |                 |
| ...              |      | 中断周期微程序  |
| 转取指周期微指令 |      |                 |
| P                | P+1  | LDA操作的微程序 |
| P+1              | P+2  |                 |
| P+2              | M    |                 |
| K                | K+1  | STA操作的微程序 |
| K+1              | K+2  |                 |
| K+2              | M    |                 |

取指周期微程序，默认是公共的，故如果某指令系统中有n条机器指令，则CM中微程序的个数至少是n+1个。

间址周期和中断周期微程序，不一定是公共的，此处做成公共的，故如果这台计算机指令系统中有n条机器指令，则CM中微程序的个数是n+3个。



#### 微指令的格式

##### 水平型微指令

一次能定义执行多个并行操作。

基本格式：操作控制 + 顺序控制

优点：微程序短，执行速度快。

缺点：微指令长，编写程序较麻烦。



##### 垂直型微指令

类似机器指令操作码的方式，由微操作码规定微指令的功能。

基本格式：微操作码(uOP) + 目的地址(Rd) + 源地址(Rs)

优点：微指令短、简单、规整，便于编写微程序。

缺点：微程序长，执行速度慢，工作效率低。



##### 混合型微指令

在垂直型的基础上增加一些不太复杂的并行操作。

微指令较短，仍便于编写。

微程序也不长，执行速度加快。



#### 微指令的编码方式

微指令的编码方式有称为微指令的控制方式，它是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。

##### 水平型微指令

1. 直接编码（直接控制）方式

   在微指令的操作控制字段中，每一位代表一个微操作命令，某位为“1”表示该控制信号有效。

   优点：简单、直观、执行速度快，操作并行性好。

   缺点：微指令字长过长，n个微命令就要求微指令的操作字段有n位，造成控存容量极大。										

   | 1，(PC) &rarr; MAR | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1，1 &rarr; R | 下地址 |
   | ------------------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ------------- | ------ |

2. 字段直接编码方式

   将微指令的控制字段分成若干“段”，每段经译码后发出控制信号。

   微命令字段分段的原则：

   - 互斥性微命令分在同一段内，相容性微命令分在不同段内。
   - 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间。
   - 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为3位时，最多只能表示7个互斥的微命令，通常用000表示不操作。

   | 001，(PC) &rarr; MAR | 00...0 | 111，1 &rarr; R | 下地址 |
   | -------------------- | ------ | --------------- | ------ |

​		优点：可以缩短微指令字长

​		缺点：要通过译码电路后再发出微命令，因此比直接编码方式慢。

3. 字段间接编码方式

   一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，故称为字段间接编码，又称隐式编码。

   优点：可进一步缩短微指令字长。

   缺点：削弱了微指令的并行控制能力，故通常作为字段直接编码方式的一种辅助手段。

   

#### 微指令的地址形成方式

1. 微指令的下地址字段指出

   微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继指令的地址，这种方式又称为断定方式

2. 根据机器指令的操作码形成

   当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成

3. 增量计数器法（CMAR）+ 1 &rarr; CMAR

4. 分支转移

   转移方式：指明判别条件。

   转移地址：指明转移成功后的去向。

   操作控制字段 + 转移方式 + 转移地址

5. 通过测试网络

6. 由硬件产生微程序入口地址

   第一条微指令地址由专门硬件产生

   中断周期由硬件产生中断周期微程序首地址



#### 微程序控制的基本概念

1. 微命令与微操作

   微命令是微操作的控制信号

   微操作是微命令的执行过程

2. 微指令与微周期

   微指令是若干微命令的集合

   微周期通常指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。

3. 主存储器与控制存储器

   主存储器用于存放程序和数据，在CPU外部，用RAM实现。

   控制存储器(CM)，用于存放微程序，在CPU内部，用ROM实现。

4. 程序与微程序

   程序是指令的有序集合，用于完成特定的功能。

   微程序是微指令的有序集合，一条指令的功能由一段微程序来实现。



#### 微程序控制单元的设计

设计步骤：

1. 分析每个阶段的微操作序列
2. 写出对应机器指令的微操作命令及节拍安排
3. 确定微指令格式
4. 编写微指令码点



##### 取指周期-微程序控制器的节拍安排

| 周期          | 时序及内容                   | 备注 |
| ------------- | ---------------------------- | ---- |
| T<sub>0</sub> | PC &rarr; MAR                | (1)  |
| T<sub>0</sub> | 1 &rarr; R                   |      |
| T<sub>1</sub> | Ad(CMDR) &rarr; CMAR         |      |
| T<sub>2</sub> | M(MAR) &rarr; MDR            | (2)  |
| T<sub>2</sub> | (PC) + 1 &rarr; PC           |      |
| T<sub>3</sub> | Ad(CMDR) &rarr; CMAR         |      |
| T<sub>4</sub> | MDR&rarr; IR                 | (3)  |
| T<sub>4</sub> | OP(IR) &rarr; 微地址形成部件 |      |
| T<sub>5</sub> | OP(IR) &CMAR                 |      |

总共由3条微指令组成



#### 微程序设计的分类

1. 静态微程序设计和动态微程序设计

   静态：微程序无需改变，采用ROM

   动态：通过改变微指令和微程序改变机器指令有利于仿真，采用EPROM

2. 毫微程序设计

   毫微程序设计的基本概念

   微程序设计用微程序解释机器指令

   毫微程序设计用毫微程序解释程序

   毫微指令与微指令的关系好比微指令与机器指令的关系



#### 硬布线与微程序的比较

| 类别     | 微程序控制器                                                 | 硬布线控制器                                                 |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 工作原理 | 微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出即可。 | 微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生 |
| 执行速度 | 慢                                                           | 快                                                           |
| 规整性   | 较规整                                                       | 繁琐、不规整                                                 |
| 应用场合 | CISC、CPU                                                    | RISC、CPU                                                    |
| 易扩充性 | 易扩充修改                                                   | 困难                                                         |



### 指令流水线概念及性能指标

#### 指令流水的定义

设取指、分析、执行3个阶段的时间都相等，用t表示，按以下几种执行方式分析n条指令的执行时间。

1. 顺序执行方式

   取指k &rarr; 分析k &rarr; 执行k &rarr; 取指k+1 &rarr; 分析k+1 &rarr; 执行k+1 ... 取指k+n &rarr; 分析k+n &rarr; 执行k+n

   总耗时T = n x 3t = 3nt

   传统冯•诺伊曼机采用顺序执行方式，又称串行执行方式。

   优点：控制简单，硬件代价小。

   缺点：执行指令的速度缓慢，在任何时刻，处理机中只有一条指令在执行，各功能部件的利用率很低。

2. 一次重叠执行方式

   取指k &rarr; 分析k &rarr; 执行k 

   ​								取指k+1 &rarr; 分析k+1 &rarr; 执行k+1 

   ​						...

   ​																		取指k+n &rarr; 分析k+n &rarr; 执行k+n

    总耗时T = 3t + (n-1) x 2t = (1 + 2n)t

   优点：程序执行时间缩短了1/3，各功能部件的利用率明显提高。

   缺点：需要付出硬件上较大的开销代价，控制过程也比顺序执行复杂了。

3. 二次重叠执行方式

   取指k &rarr; 分析k &rarr; 执行k 

   ​				取指k+1 &rarr; 分析k+1 &rarr; 执行k+1 

   ​						...

   ​									取指k+n &rarr; 分析k+n &rarr; 执行k+n

    总耗时T = 3t + (n-1) x t = (2 + n)t

   优点：与顺序执行方式相比，指令的执行时间缩短了近2/3，在理想情况下，处理机中同时有3条指令在执行。



注：也可以把每条指令的执行过程分成4个或5个阶段，分成5个阶段是比较常见的做法。



#### 指令流水的表示方法

1. 指令执行过程图

   主要用于分析指令的执行过程以及影响流水线等因素

2. 时空图

   不同的阶段所对对应的不同的硬件资源

   主要用于分析流水线的性能



#### 流水线的性能指标

##### 吞吐率

吞吐率是指在单位时间内流水线所完成的任务数量，或是输出结果的数量。

设任务数量为n；处理完成n个任务所用的时间为T<sub>k</sub>，则计算流水线吞吐率(TP)的最基本的公式为：
$$
TP = \frac{n}{T_k} \\[2ex]
一条指令的执行分为k个阶段，每个阶段耗时\Delta{t}，一般取\Delta{t} = 一个时钟周期。 \\[2ex]
T_k = (k+n-1)\Delta{t} \\[2ex]
流水线的实际吞吐量为：\\[2ex]
TP = \frac{n}{(k+n-1)\Delta{t}} \\[2ex]
当连续输入的任务n \rightarrow \infty，得最大吞吐率为TP_max = 1/\Delta{t}
$$




##### 加速比

完成同样的一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。



